\chapter{Our solution}\label{chap:oursolution}

The first attempt was to create wrapper of the \react library into the Dart language. 
This wrapper was successfully created, tested and also used in an independent commercial project. 

The problem occurs in the performance of the wrapper, 
where the bottleneck of the speed was the communication between \react created in the JavaScript and the wrapper in the Dart language. 
This bottleneck can be reduced by some adjustment and some Dart hacks, but it was still a bottleneck. 

That's why we decided to build our own library called \tiles.
Most of the performance benchmarks of the \tiles library later in this work will be compared with the \react wrapper. 

As we told in the previous part of the work, 
we decided to take inspiration from the \facebook \react library,
mainly in the API of the library, which is component based, 
with some differences in architecture.

We don't have to implement some of the additional features of the \react library, because of the nature of the Dart language.
\begin{itemize}
  \item Synthetic events \textit{(Dart unified events)}
  \item Mixins \textit{(Dart support native mixins as a part of a language)}
  \item Props type checking \textit{(Dart is optional-typed language)}
  \item Get default props and initial state \textit{(Dart work with classes which have constructors)}
  \item Changed class name \textit{(Map in dart use string, so string "class" is no more reserved word)}
  \item Test utilities \textit{(Dart has own unittest library and we work with classes and with native events, it is easily tested)}
\end{itemize}

In this next sections of this chapter we will introduce and deeply describe our Dart library \tiles.
\todo{Need decision, if write \tiles with small or capital \textbf{T}}

\section{Requirements}\label{subsec:our-architecture-requirements}

  When we designed \tiles library, we take into account some basic requirements. 
  \begin{description}
    \item{\textbf{Rendering in both, browser and server}} \hfill \\
      One of the main advantages of this library is possibility to render the same content, 
      with the same code as on the server, so in the browser.
      This resolved into package architecture and several architectural decisions.
      \begin{description}
        \item{\textbf{No template usage}} \hfill \\
          To achieve possibility to render content on both, browser and server, 
          we decided not to use templates, 
          because to parse template into something independent from DOM is far more difficult,
          then just use own structure clearly in one programming language.
      \end{description}
    \item{\textbf{Easy to use API}} \hfill \\
      Solution can be very interesting and powerful, 
      but if it don't offer reasonably easy to use API, almost no one will use it.
      \begin{description}
				\item{\textbf{\react-like API}} \hfill \\
					Because we use similar concept as JavaScript library \react,  
          which is widely used and known, 
          if we offer similar API, more people will more quickly get used to it.
      \end{description}
    \item{\textbf{Performance}} \hfill \\
      We want to offer useful library, and if want someone to use it, 
      we need to offer good performance in the competition of Dart and JavaScript UI libraries.
  \end{description}

  How we fulfilled these requirements is in detail described in next sections of this chapter.

\section{Architecture}\label{sec:our-architecture}

  In this section we describe our architecture from several points of view like 
	\nameref{subsec:our-architecture-overview}, 
  \nameref{subsec:our-architecture-structure}, 
  \nameref{subsec:our-architecture-core}, 
  \nameref{subsec:our-architecture-lifecycle}, 
  \nameref{subsec:our-architecture-events}, 
  \nameref{subsec:our-architecture-rendering} and
  \nameref{subsec:our-architecture-injecting}.

  We will focus on good understanding of how library works. 
  We will not discuss API a lot, this is the focus of next section. 

  But, of cause we add some examples, so wee will show some parts of api in this section too, 
  but they don't will be so much described as in next section.

  \subsection{Architectural overview}\label{subsec:our-architecture-overview}
	Our high level idea is based on \facebook \react library attitude. 
    We created api, whose main class is \texttt{Component}, which represents construct very similar to \react's \texttt{Component}.
    This component is mounted to an element, where it renders itself. 
    This relationship is described on \fullref{img:library-idea}.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/Idea.png}
      \caption{Idea}
      \label{img:library-idea}
    \end{figure}

    These components are placed into tree structure, which represents \mbox{\textbf{\nameref{img:library-idea-virtual-dom}}}, 
    which is then translated to the real DOM of client's browser or to the markup rendered by server application.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/IdeaObjects.png}
      \caption{Virtual DOM}
      \label{img:library-idea-virtual-dom}
    \end{figure}
    There can be the event listeners attached to these components. 
    The \textbf{events} \footnote{We work at Dart, which create browser compatibility for us, so we don't have to create synthetic events like \react.}
    are then bubbled trough a virtual DOM, instead real one.
    By this there can be the listener attached to a custom component, which doesn't have element representing it in a real DOM.

    As we work in Dart language, it is natural to try to reuse the most of code on the both, client and server side.
    The next important part of idea is \textbf{server-side rendering}.
    which should do and easy rendering of the same content on server as on the client's browser.
    It is very important for SEO purposes and smooth user experience. 

  \subsection{Structure}\label{subsec:our-architecture-structure}

    We split our library into 3 partially dependent packages. 
    \begin{description}
      \item[Tiles] \hfill \\
        \textbf{Tiles} package creates the core component's of library, focused to create and maintain virtual DOM and provide API for programmer.
        This package should be included by programmer in the files, where he defines custom components. 
        These components then can be used on both, server and browser sides.
      \item[Tiles Browser] \hfill \\
        This package is used for mounting components to the HTML elements. 
        It maintains relationships between elements and components, 
        simulates events bubbling and keeps real DOM in sync with virtual one.
      \item[Tiles Server] \hfill \\
        \textbf{Tiles Server} package maintains server-side rendering. It offers an API to render component structure to string with markup based on DOM components.
    \end{description}

    Based on the mentioned packages structure, it is quiet obvious what are the dependences between these packages.
    \texttt{\textbf{Tiles}} package is independent, 
		and both of \texttt{\textbf{Tiles Browser}} and \texttt{\textbf{Tiles Server}} are dependent on \texttt{\textbf{Tiles}} package.
    These dependences are shown on \fullref{img:library-packages}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Packages.png}
      \caption{Packages}
      \label{img:library-packages}
    \end{figure}

  \subsection{Core}\label{subsec:our-architecture-core}
    There are 4 main classes in the core of the library.
    \begin{description}
      \item[Component] 
        represents closed block of user interface, 
        that should be rendered in application.
      \item[Node]
        is a vertex in a tree of virtual DOM. 
        It contains an instance of \texttt[Component], which represents the type of this \texttt{Node}.
      \item[ComponentDescription]
        is self-explanatory. 
        It is returned from the component to describe it's children. 
				The principles are described later at this document.
      \item[NodeChange]
        represents one change in a virtual DOM, which should be applied into the real DOM. 
        This way, we are able to achieve minimal changing of the real DOM. 
        Types of change are: \texttt{CREATED, UPDATED, MOVED, DELETED}
    \end{description}

		In contrast with \facebook \react \texttt{Component}, our component provides only an API to a programmer.
    This class is the main class for a programmer using our library. 
		He doesn't need to use any other class created by our library. 
    Just some methods.

		We also have an inspiration from \react with idea of \textbf{virtual DOM}. 
		Vertices of an virtual DOM are represented by the class \texttt{Node} instead of the class \texttt{Component} to separate the functionality. 

    Each node contain an instance of \texttt{Component}. 
		The node represents the component in a virtual DOM.
    
    The diagram of relationships is shown on \fullref{img:library-core}. 
		In the next chapters we describe the main classes more in details.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.2]{images/uml/tiles/TilesCore/Core.png}
      \caption{Core of the library}
      \label{img:library-core}
    \end{figure}

    \subsubsection{Component}\label{subsubsec:our-architecture-core-component}
      The Component is the main building brick of application(library). 
      It offers api to the programmer with life-cycles, props etc. 

      Component is a class, which represents functionality of certain part of UI\footnote{UI = User Interface} in an application.
      It is created with some props and children acting as parameters of a function. 
      Main purpose of the component is to create a structure below\footnote{From the virtual DOM tree point of view} it, 
      add the event listeners and update itself based on event listener input.

      The main method of the \texttt{Component} is \texttt{List<ComponentDescription> render()}. 
      By this method component describes it's substructure.
      It will return list of children of this component, represented by instance of the class \texttt{ComponentDescription}. 
      \texttt{Node}, which owns this component (and called it's render method) will manage the rest.
      Basically, it will return the message like \textit{"This is how I should look like"}.

      Second important method is \texttt{void redraw()}, which trigger redraw of the component. 
      This redraw will be executed on the next animation frame. 

      Redraw is powered by \texttt{needUpdate} stream offered by \texttt{Component}, 
      which is automatically created in default constructor of class \texttt{Component}, 
      so it is very important, to call superclass constructor in each custom component class.

			\texttt{ComponentDescriptionFactory registerComponent(ComponentFactory factory)} is additional method helping programmer 
			for easier \texttt{ComponentDescription} creation. 
			Factories are described late in \fullref{sec:our-api}
      
    \subsubsection{DomComponent}\label{subsubsec:our-architecture-core-dom-component}
      \texttt{DomComponent} is a subclass of class \texttt{Component}. 
      This is specialized class, which represents HTML elements in the component structure.

      It has \texttt{props} saved as \texttt{Map}, because HTML element has attributes saved in \texttt{Map}.
      \texttt{render} method returns \texttt{children} member variable and \texttt{svg} and \texttt{pair} flags.

      Specific HTML elements are created based on different \texttt{ComponentFactory} and \texttt{ComponentDescriptionFactory}.
      \texttt{ComponentDescriptionFactory} is used to easily create \texttt{ComponentDescription}s of \texttt{DomComponent} in a custom component render method. 

    \subsubsection{ComponentDescription}\label{subsubsec:our-architecture-core-component-description}
      \texttt{ComponentDescription} is a description of the component. 
      It describes which type of the component should be rendered by using which parameters.

      For this purpose, it needs 4 types of information:
      \begin{itemize}
        \item \textbf{Type of the component} \hfill \\
          To create instance of a component, we need to know, what type (class) of the component it should be. 
          This information is represented by \texttt{ComponentFactory}, 
          which is function with 2 parameters, \texttt{props} and \texttt{children}, 
          which returns instance of a subclass of a \texttt{Component}.
        \item \textbf{Properties} \hfill \\
          Data which should be passed to the factory. 
					This data are used as a properties of the component.
        \item \textbf{Children} \hfill \\
          Children of described component.  
          This is useful mainly when programmer wants to render more complex structure of \texttt{DOMComponent}s.
        \item \textbf{Key} \hfill \\
					Key is an identifier of a child. 
					It is used to recognize reordering of children of the component.
					When components \texttt{render} method returns list of descriptions, 
					keys they contain are recognized and matched with keys stored in virtual DOM.

					If there is a match in key of the child in different position, child is only moved an updated. 
					If there is no match in key, default process follows.
      \end{itemize}

			Description is once created with all the parameters and then these parameters can't be changed. 
      All these parameters is set up by constructor. 

      \texttt{ComponentDescription} has one important method, which is \texttt{Component createComponent()}, 
      which creates \texttt{Component} instance with props and children from the description.

    \subsubsection{Node}\label{subsubsec:our-architecture-core-node}
      \texttt{Node} is the most important and complex class in the library.
      It providers following functionality:
			\begin{itemize}
				\item creates virtual DOM tree, maintains creating and updating of the tree based on results of component's \texttt{render} method, 
				\item listens to component's \texttt{needUpdate} stream and marks self as \textit{"dirty"} when it's component need update,
				\item and handles updating process that is rearranging children of the \texttt{Node}.
			\end{itemize}

			The node is also a vertex of the virtual DOM. 
			It store children as a list of children. 
			To use all possible optimization, node contain a \texttt{ComponentFactory} of the contained component, which is used when the virtual DOM is updated.
			It also contain \texttt{key} which is used to recognize changed position of the same child.

      Node has two important flags: \texttt{isDirty} and \texttt{hasDirtyDescendant}. 
      These flags represent information, whether the node, or its descendants, needs to be redrawn.
      If \texttt{isDirty} is true, the node needs to be updated, 
      because component of this node called \texttt{redraw} method.
      If \texttt{hasDirtyDescendant} is true,  
      there exist a descendant of this node, which wants to be updated.
      When \texttt{hasDirtyDescendant} is true and \texttt{isDirty} is false, 
      the node doesn't have to update itself, it is enough to call update on child nodes.

			Method \texttt{update({List<NodeChange> changes, bool force: false})} is executing the update process. 
			It take 2 named arguments:
			\begin{description}
				\item{\textbf{\texttt{List<NodeChange> changes}}} is used to be filled by changes generated by the update process,
				\item{\textbf{\texttt{bool force: false}}} is a flag signalizing if to update despite that node is not dirty.
			\end{description}

			The \texttt{update} method is used mostly in the browser part of an library, where it offers a possibility to get changes in the virtual DOM, which should be used to update the real one. 

      A methods logic consists of several main steps.
      \begin{enumerate}
				\item check, if update is needed by flags \texttt{isDirty}, \texttt{hasDirtyDescendant} or \texttt{force}, if no, exit,
				\item if component of this node needs to update (\texttt{isDirty == true}) or \texttt{force == true}, update this node with rearrangement of children,
				\item if any changes was generated, add them into the \texttt{changes} list
        \item set this node as not dirty and not have dirty descendant.
      \end{enumerate}

      The algorithm of rearrangement of children by calling \texttt{render} method of this component 
      and adapting node's children to returned descriptions is fully documented in the source code related to this work: 
      \url{https://github.com/cleandart/tiles/blob/master/lib/src/core/node_update_children.dart}

    \subsubsection{NodeChange}\label{subsubsec:our-architecture-core-node-change}
      \texttt{NodeChange} takes place as a record of a change in the virtual DOM. 
      It is used to mirror changes in the virtual DOM with the real DOM. 

			When some node in the virtual DOM is updated by method \texttt{update}, the list of changes is is collected.
      This list is subsequently processed by browser part of a library, which mirrors changes to the real DOM.

      \texttt{NodeChange} class has no methods (except constructor) and acts as a data chunk dedicated just for it's purpose. 
      It contains node, type of change, old and next properties. 

      Type is stored as an instance of \texttt{NodeChangeType} enum and can be one of: \texttt{CREATED}, \texttt{UPDATED}, 
      \texttt{MOVED} and \texttt{DELETED}. 
      When type is \texttt{UPDATED}, old props and new props take effect. 

  \subsection{Life-cycle}\label{subsec:our-architecture-lifecycle}

    Every instance of \texttt{Component} has its own life-cycle. 
    As every object, first it is created. 
    Subsequently, it is mounted and rendered into the virtual DOM, and then in to real DOM.

    When a "higher" node wants to update the node of the component, 
		the component will first receive props, 
		subsequently is asked if want to update, 
		if yes, it is asked for actual description of its children. 

    Sometimes the component wants to update itself (e.g. because event occurs).
    It calls redraw, then, it will be asked if really should update, and if yes, it is rendered and updated.

    At the end of component's life in the real DOM, 
    component should be notified about that.

    The whole life-cycle is shown on the \fullref{img:our-life-cycle}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.5]{images/uml/tiles/TilesCore/LifeCycle.png}
      \caption{Life cycle of a \texttt{Component}}
      \label{img:our-life-cycle}
    \end{figure}

    \subsubsection{Create}\label{subsec:our-architecture-lifecycle-create}

      The create part of life-cycle is implemented by constructor of \texttt{Component}. 
      It will receive props and optionally children as arguments and 
      it should prepare the whole state of object to live.

      An trivial example of constructor of \texttt{Component} is displayed below.
      \input{content/examples/my_component_constructor.tex}

      Constructor of an example only calls constructor of superclass \texttt{Component}.

      Example of more complex constructor should be e.g. the \texttt{Todo} component example:
      \input{content/examples/my_todo_component_constructor.tex}

    \subsubsection{Did mount}\label{subsec:our-architecture-lifecycle-didmount}

			When the component is mounted to the real DOM, user of the library should be notified about this event. 
			It is done by triggering the \textbf{Did mount} life-cycle event implemented the method \texttt{didMount}. 

			This is the place in time, were the component \textit{start to live its life} with the connection to the real DOM.
      This is the correct place to initialize for example the timers, stream listeners etc. 

      Our \texttt{MyTodoComponent} example compoent should listen for a change of the todo on the server, 
      and if it was changed, we can redraw the component.
      \input{content/examples/my_todo_component_didmount.tex}

    \subsubsection{Will receive props}\label{subsec:our-architecture-lifecycle-willreceiveprops}

			When the component is updated by "higher" ancestor, it will receive new props.
			A user of the library can need the possibility to compare these props with the old one
			and perform needed changes. 

			This is the correct place for subsequent life-cycle event \textit{Will receive props}
      implemented by the method \texttt{willReceiveProps}. 

      The example of \texttt{willReceiveProps} in \texttt{MyTodoComponent} 
      should compare the \texttt{todo} of the old and the new props and if they are not equal, 
      update change listener.
      \input{content/examples/my_todo_component_willreceiveprops.tex}
      
    \subsubsection{Should update}\label{subsec:our-architecture-lifecycle-shouldupdate}

			An optimization of the performance of an application can be done by rejecting "redraw" of the component.
			To reject this "redraw", component should be asked, if the redraw is needed. 

			This is implemented by the \texttt{shouldUpdate} method, which returns true if the component want to be redrawn. 

			By default \texttt{shouldUpdate} returns true, 
      what resolves to always updating of custom component, which doesn't implement this method.

      In a basic scenario this method recognize, 
      if the component will be rendered differently with the new props.  
      If not, it return false, else it return true.

      Example in \texttt{MyTodoComponent}:
      \input{content/examples/my_todo_component_shouldupdate.tex}

			\todo{End of the text refactoring}

    \subsubsection{Render}\label{subsec:our-architecture-lifecycle-render}

      Render is the main part of the \texttt{Component}. 

      It is implemented by method \texttt{render}, which have no attributes.
      It should return array of component descriptions which should be considered as 
      \textit{"this is how this component should look like"}.

      For example, in our \texttt{MyTodoComponent} render will return \texttt{<div>} which contains title and description of \texttt{todo}.
      \input{content/examples/my_todo_component_render.tex}

    \subsubsection{Did update}\label{subsec:our-architecture-lifecycle-didupdate}

      When life-cycle method \texttt{didUpdate}, 
      by which is implemented this life-cycle event, 
      is triggered, component, and programmer, can be sure, 
      that component is mounted and there exist elements in DOM for each DomComponent descendant.

    \subsubsection{Will unmount}\label{subsec:our-architecture-lifecycle-willunmount}

      This event is implemented by method \texttt{willUnmount}, which contain no arguments.
      
      It is called right before it is unmounted from dom. 

      This is the correct place to stop all timers and listeners.
      \input{content/examples/my_todo_component_willunmount.tex}

  \subsection{Rendering}\label{subsec:our-architecture-rendering}
    The main target of our library is rendering of a content. 
    By \texttt{Component} and \texttt{Node} we can create virtual DOM tree, 
    but now we want to render this structure into something independent from our library. 

    As our work is in the scope of web applications, we want to render it into DOM (browser rendering), 
    and also into textual representation of a DOM(server rendering).

    As we described earlier in \fullref{subsec:our-architecture-structure}, 
    these rendering types are separated to separate packages from the core package and are independent from each other. 

    \subsubsection{Server side}\label{subsec:our-architecture-rendering-server}
      On the server, we don't have DOM elements available, 
      because of that we want to render our virtual DOM structure into a string,
      which user of this library can return as a response to browser request.

      When we have string, which represents markup of DOM created from virtual DOM, 
      created by our library, we can do server-side databinding, 
      which can be reuse in the browser to smooth user experience. 

      Our target, render virtual DOM into markup string is quiet easy.
      From the programmers point of view, he will use \texttt{ComponentDescription} to describe, 
      what component he want to render. 
      Our server-side package of library will get this description, creates component from it, 
      puts it into node and perform update of node. 
      By this, virtual DOM is created. 

      Now, as we have virtual DOM, we can render it's markup by depth-first search of it's tree. 
      In the search, when we came into node, we will do something like this algorithm (pseudo-code):
      \begin{algorithm}[H]
        \KwData{node in virtual DOM}
        \KwResult{String with markup of subtree of virtual DOM with root in setted node}
        % initialization\;
        % \While{not at end of this document}{
        % read current\;
        \eIf{component is DomComponent}{
          \eIf{component is not pair}{
            write markup with attributes from props\;
          }{
            write open markup\;
            write markup for all children recursively\;
            write close markup\;
          }
        }{
          write markup for all children recursively\;
        }
        % }
        \caption{Write node into string.}
      \end{algorithm}

    \subsubsection{In browser}\label{subsec:our-architecture-rendering-browser}
      Rendering in browser is quiet more difficult than rendering to string. 
      We can use same render to string method, but we will need some connections between nodes and elements, 
      so we can't do it this simply.

      \paragraph{Initial mount}\label{par:our-architecture-rendering-browser-init} 
        First the user of the library need to do is to mount component to the HTML element. 
        Of cause, he will mount component description, not component directly.
        When component is mounting, it is created, placed into the node and after this, node is "updated". 
        It is initial update which creates virtual DOM. 

        When virtual DOM is created, we need to construct real DOM under the root element 
        (element, which was component mounted to) from "virtual image".

        For now, we describe case, that root element is empty (has no child element or node).
        Case, when it is not empty we discussed in the \fullref{subsec:our-architecture-injecting}.
        The mount is easily described by next algorithm:
        \begin{algorithm}[H]
          \KwData{node in virtual DOM and HTML element, to mount node to (mountRoot)}
          \KwResult{Mounted node into element}
          % initialization\;
          % \While{not at end of this document}{
          % read current\;
          \eIf{node.component is DomComponent}{
            \eIf{node.component is not pair}{
              create element representing component\;
              add created element to mountRoot\;
            }{
              create element representing component\;
              add created element to mountRoot\;
              \For{child in node.children} {
                run recursively with created element as mountRoot and child as node\;
              }
            }
            save relations between created element and node;
          }{
            \eIf{node.component is tex component}{
              create HTML text node with text from component\;
              add text node to mountRoot\;
              save relations between created text node and node;
            }{
              \For{child in node.children} {
                run recursively with mountRoot and child as node\;
              }
            }
          }
          % }
          \caption{Write node into string.}
        \end{algorithm}

        As we can see, algorithm is recursive and skips custom components. 
        Also it creates relations between created elements and nodes. 
        Which are these relations we discuss later, when we need them.

        By this algorithm, it is obvious, that we have real DOM with the same structure, 
        if we can obtain from virtual DOM by removing nodes with custom components 
        and connect their children with their parent.

      \paragraph{Update}\label{par:our-architecture-rendering-browser-update} 
        Later, there can be situation, that virtual DOM want to be updated. 
        This is when some node was marked as \textit{dirty}.
        Then framework perform update of this node, 
        which triggers update of the subtrees with roots in dirty nodes.
        This updates return lists of changes in virtual DOM, 
        which should be applied to browser element structure.

        These updates should be processed by it's type. 
        But for every type we need the information about which HTML element represents some node. 
        This is first relation, which we need to remember, when we initialize mounted relation, 
        relation \mbox{\texttt{Node $\rightarrow$ Element}}. 
        This relation is stored by map \texttt{Map<Node, Element>}.

        But what happened when we want to apply node change into real DOM structure?
        For each type of change something different of cause:
        \begin{description}
          \item[CREATED]
            when new node is created, it should be mounted into the DOM. 
            If it has \texttt{DomComponent} inside, HTML element will be created and placed at the correct place. 
            If it has some custom component, this change will be ignored. 
          \item[UPDATED]
            If node was updated, then if it has \texttt{DomComponent}, it's element is updated with setted props.
          \item[MOVED]
            Node or it's children(if it is node with custom component) is moved to new position.
          \item[DELETED]
            Element of node or elements of its descendants(if it is node with custom component) are removed from DOM.
        \end{description}

  \subsection{Events}\label{subsec:our-architecture-events}
    As we were created dart library which creates virtual DOM, composed from nodes, which contains components, 
    it is obvious that we can "simulate" event bubbling trough this virtual DOM. 

    This is useful to offer user of library possibility to catch events in DOM and react on them by update of state 
    and triggering of redraw of the component, if needed. So the question is, how add this possibility to programmer.

    It is important from performance point of view, because by this, we can add only one event listener for each event type in whole virtual DOM.
    We will discuss this later in \fullref{chap:performance}.

    To enable this synthetic bubbling, we need to find out, which component belongs to element on which was event triggered.

    We maintain relationship between nodes, components and HTML elements, so we can store this relations.
    By these relations we can listen to all events on root HTML element 
    (element, which is whole our virtual DOM mounted to), 
    and then, by stored relations mentioned above, assign DOM component to element on which was event triggered.

    When we have this component, we can simulate bubbling of event trough our virtual DOM. 
    This brings opportunity to "listen to events" on custom components. 
    But this is really questionable feature.

    If custom component automatically "listen to events" if have event listener in props, 
    it enable programmer to listen to event on, for example, custom button which is composed from more child DOM components.
    But this is additional functionality of DOM, which don't have to be desirable. 

    On the other hand, if custom component don't automatically listens to event, props, it will lighten library from functionality, 
    component will not have some additional functionality from that, which is created by programmer, 
    and in addition, it is easily possible component, to pass event listener, which it got from props, some of it's child components.
    
    We decided to \textbf{ADD WHAT WE DECIDED TO DO}.\todo{decide, and add decision here}

    Now, we will describe, how these synthetic event bubbling works.

    \subsubsection{Synthetic bubbling}\label{subsec:our-architecture-events-bubbling}

      When component is mounting, we store relation between HTML element, and node, which contain this component. 
      Then we check, if this component have event listeners in it. 
      If it has, we add event listener of the same event type to root HTML element, 
      which is associated to root node of virtual DOM. 
      Of cause, we will add only one listener of one event type to this element, 
      although when there is more then one descendant, which "listens" to this event type.

      Then, when this type of event occurs in HTML DOM subtree which represents our virtual DOM, 
      it will bubble up to the root HTML element, there it is caught by our event listener. 
      This event listener will recognize on which HTML element was event triggered, 
      find representing node in virtual DOM, and start "bubbling" from it.

      Bubbling is done by checking if component of this node have event listener for this type of event in it's props.
      If it contain it, listener is called with event and components as arguments. 

      We pass component as an argument because this listener is not created by this component itself, 
      but by component above it, and it should be informed, on which component this listener was called.

      If this listener didn't returns \texttt{false}, bubbling continues to parent node. 
      When root is achieved, bubbling stops and real event listener, 
      which simulate internal event bubbling, ends.

      There exist better solution for stopping synthetic event bubbling then returning false from event listener 
      by calling \texttt{stopPropagation} method on event, which stop bubbling in real DOM. 
      But there exist no official way of getting this information from event object. 

      This is resolvable, in multiple ways. For example, by creating "synthetic" event
      which should encapsulate real event object and store information that \texttt{stopPropagation} was called.
      But this solution creates some problems, e.g. multiple types of events in dart, 
      represented by different classes with not the same api.
      Because of this, we decided to not add this ideal functionality for now, while there not exists official way this information from event object.

      Other solution, and in our opinion best one, 
      is to add official way of getting information if \texttt{stopPropagation} was called to core Dart \texttt{Event} class.
      But this is out of the scope of our library, so we created feature request to Dart developers and hope they will implement it.

  \subsection{Injecting}\label{subsec:our-architecture-injecting}

    We added possibility to render whole HTML structure on server and add it to requested HTML.

    This is good for user experience, because user of the application can see the result of his request event before JavaScript/Dart is loaded.
    But if our browser package replace this structure with new DOM structure, 
    generated from virtual DOM, it should be annoying for user of the application, because the part of the page, 
    which is represented by virtual DOM, will disappear for a short time and then appear back in the same look. 

    To prevent this, we created injecting system, which will inject existing DOM structure and rebuild it to represent virtual DOM.

    When the \texttt{ComponentDescription} is mounting, basic implementation can erase whole content of element to which is description mounted to.
    Instead of this, we will reuse existing structure by iterating trough virtual DOM and reusing every element, which match virtual DOM. 

    When we iterate trough virtual DOM and get to node with DOM component, we will look at the currently processed HTML element.
    If it match the type of DOM component (by tag name), 
    it is associated with this node, 
    adapted to represent it in real DOM\footnote{By changing attributes to correct state}, 
    used to mount children of this node under it with the same process recursively,
    and processing of elements move to next sibling of current element.

    When current element don't match type of DOM component, 
    new HTML element is inserted before it and paired with this node. 
    By this, other DOM component at the same layer of the DOM component tree
    \footnote{
      By DOM component tree we mean derived tree from virtual DOM tree, 
      which can be constructed by removing nodes with custom components
      and connecting nodes with DOM components to closest ancestor in virtual DOM tree with DOM component in it.
    }
    can reuse this not matching element.
    When one layer of the DOM component tree is finished
    (which is when iteration go to the node, which contain DOM component associated with parent HTML element),
    rest of the original HTML elements in this layer of DOM is erased. 

    By these simple and lightweight comparisons, if the html was created by the same components with the same data on server, 
    library will reuse whole html with no change and inject needed relations to the virtual DOM to the real one. 

    Moreover if there exist some similar structure, not generated by same components on the server, 
    our library will reuse as much as possible with not too complex and heavy comparison machinery.

\section{API}\label{sec:our-api}

  One product of this work is open source UI library.
  To use this library, user need to know the application programming interface(API) of it. 

  In \tiles library, user interface rendered by it consist of components, represented by the class \texttt{Component}. 
  This class is used to create functional logic of part of the UI. 

  To use it, mount it, add it to other component as a child, it is necessary to create \texttt{ComponentFactory}, 
  \texttt{ComponentDescription} and optionally \texttt{ComponentDescriptionFactory}.

  \textbf{\texttt{ComponentFactory}} is a function with two positional optional arguments \texttt{props} and \texttt{children}, 
  which return instance of the Component, ideally new with setted \texttt{props} and \texttt{children}.
  The easiest and most common way to create ComponentFacotry is shown in next example:
  \input{content/examples/component_factory.tex}

  \textbf{\texttt{ComponentDescription}} is something, what describes component. 
  It is used as argument to mounting functions and as result of \texttt{render} method.
  It is mostly not used directly, but by \texttt{ComponentDescriptionFactory}, 
  which is method with the same arguments as \texttt{ComponentFacotry}, and returns instance of \texttt{ComponentDescription}.

  It can be created by programmer himself, but mainly, it is created by \texttt{registerComponent} function, which accept one argument of \texttt{ComponentFacotry} type.
  This method created \texttt{ComponentDescriptionFactory}, which returns description with passed \texttt{ComponentFacotry}.
  Usage is shown on following example:
  \input{content/examples/register_component.tex}

  This \texttt{ComponentDescriptionFactory} is then used to create description or directly in mounting into HTML element:
  \input{content/examples/mount_component_description_factory.tex}

  \subsection{Component}\label{subsec:our-api-component}

    \texttt{Component} class is the main class of the API.
    Every custom component should extend or implement it. 

    It contains constructor, life-cycle methods, \texttt{render} and \texttt{redraw} method, props, children and offer \texttt{needUpdate} stream.
    The whole default \texttt{Component} is this: 
    \input{content/examples/component.tex}

    The easier way to create own component is by extending, not by implementing it, because extending add default functionality. 
    Simple component should look like this:
    \input{content/examples/my_component.tex}

    We can see, that this \texttt{MyComponent} only renders \texttt{ComponentDescription} of div DOM component which contain children with span description.
    \footnote{DOM component API will be discussed later.}

  \subsection{DOM component API}\label{subsec:our-api-dom}

    There are prepared \texttt{ComponentDescriptionFactory} functions for each of standard HTML elements, which gets standard arguments. 
    They will create new \texttt{ComponentDescription}, with correct factory, which created \texttt{DomComponent} with appropriate tag name.

    These factories can be used like on example of \texttt{MyComponent} in \texttt{render} function.

  \subsection{Browser specific API}\label{subsec:our-api-browser}
    
    There are 3 main addition when components are rendered in browser.
    \begin{itemize}
      \item Mounting
      \item References
      \item Event listeners
    \end{itemize}

    \textbf{Mounting} is implemented by \texttt{mountComponent} function, which have 2 arguments, 
    \texttt{ComponentDescription description} and \texttt{Element mountRoot}.
    It will mount described component into \texttt{mountRoot} element.
    \input{content/examples/mount_component_description_factory_only.tex}

    \textbf{References} are part of props. If component have in \texttt{props["ref"]} instance of internal class \texttt{{\textunderscore}Ref}, 
    which is only function returning void with one \texttt{Component} argument, then when this component is created and mounted, 
    this \texttt{{\textunderscore}Ref} is called with it. 

    It is useful, when some custom component want to have reference to element associated to some of it's descendant. 
    Example of usage is something like this:
    \input{content/examples/ref.tex}

    \textbf{Event listeners} are also represented as part of props. 
    They should be instance of \texttt{EventListener} class, which is function with 2 arguments, event and component and returns boolean.
    They are used in the same way as references, by adding to props with key in format \texttt{onEventType}:
    \input{content/examples/event_listener.tex}

  \subsection{Server specific API}\label{subsec:our-api-server}

    There is only one thing we want to do on the server, and that is to create markup for some \texttt{ComponentDescription}.
    For this purpose we created method \texttt{mountComponentToString}, which accepts 1 \texttt{ComponentDescription} argument and returns markup, 
    which is identical to what browser part of library should create in DOM.
    \input{content/examples/mount_component_to_string.tex}
