\chapter{Our solution}\label{chap:oursolution}

In this chapter we will introduce and deeply describe our Dart library \texttt{Tiles}.


\section{Requirements}\label{subsec:our-architecture-requirements}

  In this section we write down a list of requirements on our library.

\section{Architecture}\label{sec:our-architecture}

  In this section we describe our architecture from couple points of view like \nameref{subsec:our-architecture-idea}, 
  \nameref{subsec:our-architecture-structure}, 
  \nameref{subsec:our-architecture-core}, 
  \nameref{subsec:our-architecture-lifecycle}, 
  \nameref{subsec:our-architecture-events}, 
  \nameref{subsec:our-architecture-rendering} and
  \nameref{subsec:our-architecture-injecting}.

  We will focus on good understanding of how library works. 
  We will not discuss API a lot, this is the focus of next section. 

  But, of cause we add some examples, so wee will show some parts of api in this section too, 
  but they don't will be so much described as in next section.

  \subsection{High level idea}\label{subsec:our-architecture-idea}
    Our high level idea inherit from facebook react library. 
    We created api, whose main class is \texttt{Component}, which represents construct very similar to react's \texttt{Component}.
    This component is mounted to some element, where it renders itself. 
    This relationship is shown on figure~\nameref{img:library-idea}.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/Idea.png}
      \caption{Idea}
      \label{img:library-idea}
    \end{figure}


    These components are somehow placed into tree structure, which represents \mbox{\textbf{\nameref{img:library-idea-virtual-dom}}}, 
    which is then translated to real DOM of client's browser or to markup rendered by server application.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/IdeaObjects.png}
      \caption{Virtual DOM}
      \label{img:library-idea-virtual-dom}
    \end{figure}
    There can be event listeners attached to these components. 
    \textbf{Events} \footnote{We work at Dart, which create browser compatibility for us, so we don't have to create synthetic events like react.}
    are then bubbled trough virtual DOM, instead real one.
    By this there can be listener attached to custom component, which don't have element representing it in real DOM.

    As we work in Dart language, it is natural to try to reuse most of code on both, client and server.
    So other important part of idea is \textbf{server-side rendering}, 
    which is meant to easy rendering the same content on server as on client's browser.
    It is very important for SEO purposes and smooth user experience. 

  \subsection{Structure}\label{subsec:our-architecture-structure}

    We split our library to 3 partially dependent packages. 
    \begin{description}
      \item[Tiles] \hfill \\
        \textbf{Tiles} creates the core component's of library, focused to create and maintain virtual DOM and offer API for programmer.
        This package should be included by programmer in files, where he define custom components. 
        These components then can be used both, on server and in browser application.
      \item[Tiles Browser] \hfill \\
        These package is used for mounting components to real HTML elements. 
        It maintain relationships between elements and components, 
        simulate events bubbling and keep real DOM in sync with virtual one.
      \item[Tiles Server] \hfill \\
        \textbf{Tiles Server} maintain server-side rendering. It offers api to render component structure to string with markup based on DOM components.
    \end{description}

    From this it is quiet obvious what are dependences between these packages. 
    \texttt{\textbf{Tiles}} is independent, and both of \texttt{\textbf{Tiles Browser}} and \texttt{\textbf{Tiles Server}} are dependent on \texttt{\textbf{Tiles}}.
    These dependences are shown on figure~\nameref{img:library-packages}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Packages.png}
      \caption{Packages}
      \label{img:library-packages}
    \end{figure}

  \subsection{Core}\label{subsec:our-architecture-core}
    We have 4 main classes in core of the library.
    \begin{description}
      \item[Component] 
        represents closed block of user interface, 
        which should be rendered in application.
      \item[Node]
        is a vertex in tree of virtual DOM. 
        It contains instance of \texttt[Component], which represents type of this \texttt{Node}.
      \item[ComponentDescription]
        is, as it sound like, description of a component. 
        It is returned from component to describe it's children. 
        We discuss this principle later.
      \item[NodeChange]
        represents one change in virtual DOM, which should be applied into real DOM. 
        By this, we achieve changing real DOM by smallest difference in virtual DOM. 
        Types of change are \texttt{CREATED, UPDATED, MOVED, DELETED}
    \end{description}

    In contrast with facebook react \texttt{Component}, our component do nothing else than api offered to programmer.
    This class is the main class for programmer which use our library, he don't need to use any other class created by our library. 
    Just some methods.

    We also got inspiration from react with idea of \textbf{virtual DOM}. 
    This virtual DOM is not represented by tree of components, but to separate functionality, 
    it's vertices are constructed by instances of class \texttt{Node}.

    Every node contain instance of \texttt{Component}. 
    For this \texttt{Component} instance this node is something like \textit{representer of me in virtual DOM}.
    
    The whole image of relationships is shown on figure~\nameref{img:library-core}. Now we will focus on the main classes separately. 
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.2]{images/uml/tiles/TilesCore/Core.png}
      \caption{Core of the library}
      \label{img:library-core}
    \end{figure}

    \subsubsection{Component}\label{subsubsec:our-architecture-core-component}
      Component, as in react, is the main building brick of application(library). 
      It offers api to the programmer with life-cycles, props and so on. 

      Life-cycle methods will be discuss later, lets focus on the role of component in the whole library.

      Component is a class, which represents functionality of certain part of UI\footnote{UI = User Interface} in an application.
      It is created with some props and children and it is upon it to do what ever it wants with it. 
      But main purpose of it is to create some structure below\footnote{From the virtual DOM tree point of view} it, 
      add some event listeners and update itself sometimes, e.g. on some event occur.

      The main method of the \texttt{Component} is \texttt{List<ComponentDescription> render()}. 
      By this method component creates it's substructure.
      It will return list of children of this component, represented by instance of \texttt{ComponentDescription}. 
      \texttt{Node}, which owns this component (and called it's render method) will take care of the rest.
      Basically, it will return something like \textit{"This is how I should look like"}.

      Second important method is \texttt{void redraw()}, which trigger redraw of the component. 
      This redraw will be executed on the first next animation frame. 

      Redraw is powered by \texttt{needUpdate} stream offered by \texttt{Component}, 
      which is automatically created in default constructor of class \texttt{Component}, 
      so it is very important, to call superclass constructor in each custom component class.

      \texttt{ComponentDescriptionFactory registerComponent(ComponentFactory factory)} is also very helpful method. 
      By passing it it gets \texttt{ComponentFactory} as an argument and from it, create \texttt{ComponentDescriptionFactory}. 
      This is mainly created for easy use of the library, we will show why these factories exists and how are they used in section~\nameref{sec:our-api}
      
    \subsubsection{DomComponent}\label{subsubsec:our-architecture-core-dom-component}
      \texttt{DomComponent} is a subclass of class \texttt{Component}. 
      This is specialized class, which represents HTML elements in the component structure.

      It has \texttt{props} saved as \texttt{Map}, because HTML element have attributes saved in \texttt{Map},
      \texttt{render} method, which return \texttt{children} member variable and \texttt{svg} and \texttt{pair} flags.

      Specific HTML elements are then created as with different \texttt{ComponentFactory} and also different \texttt{ComponentDescriptionFactory}, 
      which is used to easily create \texttt{ComponentDescription}s of \texttt{DomComponent} in custom component render method. 

    \subsubsection{ComponentDescription}\label{subsubsec:our-architecture-core-component-description}
      \texttt{ComponentDescription} is description of a component. 
      It describes what component should be rendered.

      For this purpose, it's need 4 types of information:
      \begin{itemize}
        \item \textbf{Type of the component} \hfill \\
          To create instance of some component, we need to know, what type (class) of the component it should be. 
          This information is represented by \texttt{ComponentFactory}, 
          which is function with 2 parameters, \texttt{props} and \texttt{children}, 
          which returns instance of a subclass of a \texttt{Component}.
        \item \textbf{Properties} \hfill \\
          Data which should be passed to the factory, to be new component created with them.
        \item \textbf{Children} \hfill \\
          Children of described component.  
          This is useful mainly when programmer want to render more complex structure of \texttt{DOMComponent}s.
        \item \textbf{Key} \hfill \\
          Key is an identifier of a child. If component's function render returns list of children with keys, 
          and after update it returns the same children but in different positions, 
          tiles only reorder this children and not remove, add them or change their properties. 
      \end{itemize}

      It has all these information as final. Description is once created, 
      with all informations and then these information can't be changed. 
      All these information is setted up bu constructor. 

      \texttt{ComponentDescription} have one important method, which is\texttt{Component createComponent()}, 
      which creates \texttt{Component} instance with props and children from the description.

    \subsubsection{Node}\label{subsubsec:our-architecture-core-node}
      \texttt{Node} is the most important and complex class in the library.
      It creates virtual DOM tree, maintain creating and updating of it based on results of component's \texttt{render} method, 
      listen to component's \texttt{needUpdate} stream and mark self as \textit{"dirty"} when it's component need update 
      and handle process of updating which rearrange children of the \texttt{Node}.

      Children are stored trough class \texttt{NodeChild}, which represents all information about child (node, component's factory and key). 
      By this encapsulation, when update is triggered, we can compare factory of a component description and factory of a child 
      and decide, if we need to replace this child or it is enough to update it. 

      As the key is also stored in \texttt{NodeChild}, we also compare old children with next one when doing update, 
      and if there exists child in old children with the same key as in the next one, this child "step out of the line" 
      and only move around without replacing.
      
      Node have two important flags: \texttt{isDirty} and \texttt{hasDirtyDescendant}. 
      These flags represents information, if some node need to be redrawn.
      If \texttt{isDirty} is true, this node need to be updated, 
      because component of this node called \texttt{redraw}.
      If \texttt{hasDirtyDescendant} is true, that means, 
      that there exist a descendant of this node, which want to be updated.
      When \texttt{hasDirtyDescendant} is true and \texttt{isDirty} is false, 
      component don't have to update itself, it is enough to call update on child nodes.

      Method \texttt{List<NodeChange> update()} is doing this update process. 
      It returns list of changes, which was needed to put node in new state.
      This update is mainly called by browser part of a library and this list is used to translate changes in virtual DOM to real one. 
      Method consists of several main steps.
      \begin{enumerate}
        \item check, if update is needed by flags \texttt{isDirty} and \texttt{hasDirtyDescendant}, if no, return,
        \item if component of this node need update (\texttt{isDirty == true}), update this node with rearrangement of children,
        \item add results of update calls on children to result,
        \item set this node as not dirty and not have dirty descendant and return.
      \end{enumerate}

      Rearrangement of children by calling \texttt{render} method of this component 
      and adapting node's children to returned descriptions 
      has not so difficult as complex algorithm, which we will not describe here. 
      It is fully documented in the source code related to this work, 
      extracted to specific method private to the library which is in own file:
      \url{https://github.com/cleandart/tiles/blob/master/lib/src/core/node_update_children.dart}

    \subsubsection{NodeChange}\label{subsubsec:our-architecture-core-node-change}
      \texttt{NodeChange} take place as a record of a change in the virtual DOM. 
      It is used to mirror changes in the virtual DOM with real DOM. 

      When some node in the virtual DOM is updated by method \texttt{update}, list of changes is returned. 
      This list is then processed by browser part of a library, which mirror these changes to real DOM.

      \texttt{NodeChange} class has no methods (except constructor) and act just as a data chunk specialized for it's purpose. 
      It contains node, type of change, old and next properties. 

      Type is stored as instance of \texttt{NodeChangeType} enum and can be one of \texttt{CREATED}, \texttt{UPDATED}, 
      \texttt{MOVED} and \texttt{DELETED}, whom meaning is obvious. 
      When type is \texttt{UPDATED}, old props and new pros take effect. 

  \subsection{Life-cycle}\label{subsec:our-architecture-lifecycle}

    Every instance of \texttt{Component} have own life-cycle. 
    As every object, first it is created. 
    Then, when component is mounting or rendering into text, it is rendered, and then it is mounted.
    Then it lives it's own life. 

    When something "higher" want to update it, it will first receive props, 
    then it is asked, if it should be updated, and if yes, then it is rendered.
    After that, it was updated, of course.

    Sometimes component want to update itself (e.g. because some event occurs).
    It calls redraw, then, it will be asked if really should update, and if yes, it is rendered and update.

    At the end of component's life, 
    component should be notified about that it will be unmounted(e.g. from DOM), 
    to be able, to do some modifications to it's refs, destroy timers and so on. 

    This whole life-cycle is shown on the figure~\nameref{img:our-life-cycle}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/TilesCore/LifeCycle.png}
      \caption{Life cycle of a \texttt{Component}}
      \label{img:our-life-cycle}
    \end{figure}

    \subsubsection{Create}\label{subsec:our-architecture-lifecycle-create}

      Create part of life-cycle is implemented by constructor of \texttt{Component}. 
      It will receive props and optionally children as arguments and 
      it should do whatever it needs to prepare whole state of object to live.

      An trivial example of constructor of \texttt{Component} is 
      \input content/examples/my_component_constructor.tex
      which only call's constructor of super class \texttt{Component}

      Example of more complex constructor should be e.g. component 
      which maintain example \texttt{Todo} instance.
      \input content/examples/my_todo_component_constructor.tex

    \subsubsection{Did mount}\label{subsec:our-architecture-lifecycle-didmount}

      \texttt{Component} life-cycle \textbf{Did mount} is implemented by method \texttt{didMount}. 
      It is called after component is mounted to DOM. 

      This is the correct place to initialize for example timers, stream listeners and so on. 

      For example, in our \texttt{MyTodoComponent} we should listen for change of todo on server, 
      and if it was changed, we can redraw component.
      \input content/examples/my_todo_component_didmount.tex

    \subsubsection{Will receive props}\label{subsec:our-architecture-lifecycle-willreceiveprops}

      Will receive props life-cycle method is \texttt{willReceiveProps}. 
      It is called every time, when component will recevie new \texttt{props}, 
      except first time, when these \texttt{props} are passed to constructor.

      This is place, where old props and new props can be compared, 
      so this is right place to make changes based on difference in old and new props.

      Example of \texttt{willReceiveProps} in our \texttt{MyTodoComponent} 
      should compare \texttt{todo} of old and new props and there are not equal, 
      it can update change listener.
      \input content/examples/my_todo_component_willreceiveprops.tex
      
      
    \subsubsection{Should update}\label{subsec:our-architecture-lifecycle-shouldupdate}
      Should update is partly lifecycle, partly not. 
      It is a question, if component should update on  this props-change. 

      This "life-cycle" is implemented by method \texttt{shouldUpdate}. 
      This method is used mainly for speed up performance. 
      By default it returns true, 
      so if it is not implemented in custom component, 
      it will update always.

      In basic scenario this method recognize, 
      if it will be rendered differently with new props.  
      If not, it return false, else it return true.

      Example in \texttt{MyTodoComponent} should look like this:
      \input content/examples/my_todo_component_shouldupdate.tex

    \subsubsection{Render}\label{subsec:our-architecture-lifecycle-render}

      Render is the main part of the \texttt{Component}. 

      It is implemented by method \texttt{render}, which have no attributes.
      It should return array of component descriptions which should be considered as 
      \textit{"this is how this component should look like"}.

      For example, in our \texttt{MyTodoComponent} render will return \texttt{<div>} which contains title and description of \texttt{todo}.
      \input content/examples/my_todo_component_render.tex

    \subsubsection{Did update}\label{subsec:our-architecture-lifecycle-didupdate}

      When life-cycle method \texttt{didUpdate}, 
      by which is implemented this life-cycle event, 
      is triggered, component, and programmer, can be sure, 
      that component is mounted and there exist elements in DOM for each DomComponent descendant.

    \subsubsection{Will unmount}\label{subsec:our-architecture-lifecycle-willunmount}

      This event is implemented by method \texttt{willUnmount}, which contain no arguments.
      
      It is called right before it is unmounted from dom. 

      This is the correct place to stop all timers and listeners.
      \input content/examples/my_todo_component_willunmount.tex

  \subsection{Rendering}\label{subsec:our-architecture-rendering}
    The main target of our library is rendering of a content. 
    By \texttt{Component} and \texttt{Node} we can create virtual DOM tree, 
    but now we want to render this structure into something independent from our library. 

    As our work is in the scope of web applications, we want to render it into DOM (browser rendering), 
    and also into textual representation of a DOM(server rendering).

    As we described earlier in subsection~\nameref{subsec:our-architecture-structure}, 
    these rendering types are separated to separate packages from the core package and are independent from each other. 

    \subsubsection{Server side}\label{subsec:our-architecture-rendering-server}
      On the server, we don't have DOM elements available, 
      because of that we want to render our virtual DOM structure into a string,
      which user of this library can return as a response to browser request.

      When we have string, which represents markup of DOM created from virtual DOM, 
      created by our library, we can do server-side databinding, 
      which can be reuse in the browser to smooth user experience. 

      Our target, render virtual DOM into markup string is quiet easy.
      From the programmers point of view, he will use \texttt{ComponentDescription} to describe, 
      what component he want to render. 
      Our server-side package of library will get this description, creates component from it, 
      puts it into node and perform update of node. 
      By this, virtual DOM is created. 

      Now, as we have virtual DOM, we can render it's markup by depth-first search of it's tree. 
      In the search, when we came into node, we will do something like this algorithm (pseudo-code):
      \begin{algorithm}[H]
        \KwData{node in virtual DOM}
        \KwResult{String with markup of subtree of virtual DOM with root in setted node}
        % initialization\;
        % \While{not at end of this document}{
        % read current\;
        \eIf{component is DomComponent}{
          \eIf{component is not pair}{
            write markup with attributes from props\;
          }{
            write open markup\;
            write markup for all children recursively\;
            write close markup\;
          }
        }{
          write markup for all children recursively\;
        }
        % }
        \caption{Write node into string.}
      \end{algorithm}

    \subsubsection{In browser}\label{subsec:our-architecture-rendering-browser}
      Rendering in browser is quiet more difficult than rendering to string. 
      We can use same render to string method, but we will need some connections between nodes and elements, 
      so we can't do it this simply.

      \paragraph{Initial mount}\label{par:our-architecture-rendering-browser-init} 
        First the user of the library need to do is to mount component to the HTML element. 
        Of cause, he will mount component description, not component directly.
        When component is mounting, it is created, placed into the node and after this, node is "updated". 
        It is initial update which creates virtual DOM. 

        When virtual DOM is created, we need to construct real DOM under the root element 
        (element, which was component mounted to) from "virtual image".

        For now, we describe case, that root element is empty (has no child element or node).
        Case, when it is not empty we discussed in the subsection~\nameref{subsec:our-architecture-injecting}.
        The mount is easily described by next algorithm:
        \begin{algorithm}[H]
          \KwData{node in virtual DOM and HTML element, to mount node to (mountRoot)}
          \KwResult{Mounted node into element}
          % initialization\;
          % \While{not at end of this document}{
          % read current\;
          \eIf{node.component is DomComponent}{
            \eIf{node.component is not pair}{
              create element representing component\;
              add created element to mountRoot\;
            }{
              create element representing component\;
              add created element to mountRoot\;
              \For{child in node.children} {
                run recursively with created element as mountRoot and child as node\;
              }
            }
            save relations between created element and node;
          }{
            \eIf{node.component is tex component}{
              create HTML text node with text from component\;
              add text node to mountRoot\;
              save relations between created text node and node;
            }{
              \For{child in node.children} {
                run recursively with mountRoot and child as node\;
              }
            }
          }
          % }
          \caption{Write node into string.}
        \end{algorithm}

        As we can see, algorithm is recursive and skips custom components. 
        Also it creates relations between created elements and nodes. 
        Which are these relations we discuss later, when we need them.

        By this algorithm, it is obvious, that we have real DOM with the same structure, 
        if we can obtain from virtual DOM by removing nodes with custom components 
        and connect their children with their parent.

      \paragraph{Update}\label{par:our-architecture-rendering-browser-update} 
        Later, there can be situation, that virtual DOM want to be updated. 
        This is when some node was marked as \textit{dirty}.
        Then framework perform update of this node, 
        which triggers update of the subtrees with roots in dirty nodes.
        This updates return lists of changes in virtual DOM, 
        which should be applied to browser element structure.

        These updates should be processed by it's type. 
        But for every type we need the information about which HTML element represents some node. 
        This is first relation, which we need to remember, when we initialize mounted relation, 
        relation \mbox{\texttt{Node $\rightarrow$ Element}}. 
        This relation is stored by map \texttt{Map<Node, Element>}.

        But what happened when we want to apply node change into real DOM structure?
        For each type of change something different of cause:
        \begin{description}
          \item[CREATED]
            when new node is created, it should be mounted into the DOM. 
            If it has \texttt{DomComponent} inside, HTML element will be created and placed at the correct place. 
            If it has some custom component, this change will be ignored. 
          \item[UPDATED]
            If node was updated, then if it has \texttt{DomComponent}, it's element is updated with setted props.
          \item[MOVED]
            Node or it's children(if it is node with custom component) is moved to new position.
          \item[DELETED]
            Element of node or elements of its descendants(if it is node with custom component) are removed from DOM.
        \end{description}

  \subsection{Events}\label{subsec:our-architecture-events}
    As we were created dart library which creates virtual DOM, composed from nodes, which contains components, 
    it is obvious that we can "simulate" event bubbling trough this virtual DOM. 

    This is fully in domain browser part of a library.
    \todo{Add more content.}

  \subsection{Injecting}\label{subsec:our-architecture-injecting}

\section{API}\label{sec:our-api}

  Documentation of offered API of our library.

  \subsection{Component}\label{subsec:our-api-component}
  \subsection{Browser specific API}\label{subsec:our-api-browser}
  \subsection{Server specific API}\label{subsec:our-api-server}
