\chapter{Our solution}\label{chap:oursolution}

The first attempt was to create wrapper of the \react library into the Dart language. 
This wrapper was successfully created, tested and also used in an independent commercial project. 

The problem occurs in the performance of the wrapper, 
where the bottleneck of the speed was the communication between \react created in the JavaScript and the wrapper in the Dart language. 
This bottleneck can be reduced by some adjustment and some Dart hacks, but it was still a bottleneck. 

That's why we decided to build our own library called \tiles.
Most of the performance benchmarks of the \tiles library later in this work will be compared with the \react wrapper. 

As we told in the previous part of the work, 
we decided to take inspiration from the \facebook \react library,
mainly in the API of the library, which is component based, 
with some differences in architecture.

We don't have to implement some of the additional features of the \react library, because of the nature of the Dart language.
\begin{itemize}
  \item Synthetic events \textit{(Dart unified events)}
  \item Mixins \textit{(Dart support native mixins as a part of a language)}
  \item Props type checking \textit{(Dart is optional-typed language)}
  \item Get default props and initial state \textit{(Dart work with classes which have constructors)}
  \item Changed class name \textit{(Map in dart use string, so string "class" is no more reserved word)}
  \item Test utilities \textit{(Dart has own unittest library and we work with classes and with native events, it is easily tested)}
\end{itemize}

In this next sections of this chapter we will introduce and deeply describe our Dart library \tiles.

\section{Requirements}\label{subsec:our-architecture-requirements}

  When we designed the \tiles library, we take into account requirements derived from the motivation of this work:

  \begin{description}
    \item{\textbf{Rendering in both environments, the browser and the server}} \hfill \\
      One of the main advantages of \tiles library is a possibility to render the same content, 
      with the same code as on the server, so in the browser.
      This resolved into the package structure and several architectural decisions.
      \begin{description}
        \item{\textbf{No template usage}} \hfill \\
          To achieve a possibility to render content in both environments, easy testing and mocking, 
          we decided not to use templates.
      \end{description}
    \item{\textbf{Easy to use API}} \hfill \\
      The solution can be very interesting and powerful, 
      but if it don't offer a reasonably easy to use API, almost no one will use it.
      \begin{description}
        \item{\textbf{\react-like API}} \hfill \\
          Because we use a similar concept as the JavaScript \react library,  
          which is widely used and known, 
          if we offer similar API, more people will quickly get used to it.
      \end{description}
    \item{\textbf{Performance}} \hfill \\
      We want to offer the useful library, and if want someone to use it, 
      we need to offer a good performance in the competition of Dart and JavaScript UI libraries.
  \end{description}

  How we fulfilled these requirements is in detail described in next sections of this chapter.

\section{Architecture}\label{sec:our-architecture}

  In this section we describe our architecture from several points of view like 
  \nameref{subsec:our-architecture-overview}, 
  \nameref{subsec:our-architecture-structure}, 
  \nameref{subsec:our-architecture-core}, 
  \nameref{subsec:our-architecture-lifecycle}, 
  \nameref{subsec:our-architecture-events}, 
  \nameref{subsec:our-architecture-rendering} and
  \nameref{subsec:our-architecture-injecting}.

  We will focus on good understanding of how library works. 
  We will not discuss API a lot, this is the focus of next section. 

  But, of cause we add some examples, so wee will show some parts of api in this section too, 
  but they don't will be so much described as in next section.
  \todo{this content need to be replaced}

  \subsection{Architectural overview}\label{subsec:our-architecture-overview}
    Our high level idea is based on the \facebook \react library attitude. 
    We created api, whose main class is \texttt{Component}, which represents construct very similar to \react's \texttt{Component}.
    This component is mounted to an element, where it renders itself. 
    This relationship is described on \fullref{img:library-idea}.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/Idea.png}
      \caption{The Idea}
      \label{img:library-idea}
    \end{figure}

    These components are placed into tree structure, which represents \mbox{\textbf{\nameref{img:library-idea-virtual-dom}}}, 
    which is then translated to the real DOM of client's browser or to the markup rendered by server application.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/IdeaObjects.png}
      \caption{Virtual DOM}
      \label{img:library-idea-virtual-dom}
    \end{figure}
    There can be the event listeners attached to these components. 
    The \textbf{events} 
    \footnote{We work at Dart, which create browser compatibility for us, so we don't have to create synthetic events like \react.}
    are then bubbled trough a virtual DOM, instead real one.
    By this there can be the listener attached to a custom component, which doesn't have element representing it in a real DOM.

    As we work in Dart language, it is natural to try to reuse the most of code on the both, client and server side.
    The next important part of architecture is \textbf{server-side rendering}.

    It is very important for SEO purposes and smooth user experience. 

  \subsection{Structure}\label{subsec:our-architecture-structure}

    We split our library into 3 partially dependent packages. 
    \begin{description}
      \item[Tiles] \hfill \\
        \textbf{Tiles} package creates the core component's of library, focused to create and maintain virtual DOM and provide API for programmer.
        This package should be included by programmer in the files, where he defines custom components. 
        These components then can be used on both, server and browser sides.
      \item[Tiles Browser] \hfill \\
        This package is used for mounting components to the HTML elements. 
        It maintains relationships between elements and components, 
        simulates events bubbling and keeps real DOM in sync with virtual one.
      \item[Tiles Server] \hfill \\
        \textbf{Tiles Server} package maintains server-side rendering. It offers an API to render component structure to string with markup based on DOM components.
    \end{description}

    Based on the mentioned packages structure, it is quiet obvious what are the dependences between these packages.
    \texttt{\textbf{Tiles}} package is independent, 
    and both of \texttt{\textbf{Tiles Browser}} and \texttt{\textbf{Tiles Server}} are dependent on \texttt{\textbf{Tiles}} package.
    These dependences are shown on \fullref{img:library-packages}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Packages.png}
      \caption{Packages}
      \label{img:library-packages}
    \end{figure}

  \subsection{Core}\label{subsec:our-architecture-core}
    There are 4 main classes in the core of the library.
    \begin{description}
      \item[Component] 
        represents closed block of user interface, 
        that should be rendered in application.
      \item[Node]
        is a vertex in a tree of virtual DOM. 
        It contains an instance of \texttt[Component], which represents the type of this \texttt{Node}.
      \item[ComponentDescription]
        is self-explanatory. 
        It is returned from the component to describe it's children. 
        The principles are described later at this document.
      \item[NodeChange]
        represents one change in a virtual DOM, which should be applied into the real DOM. 
        This way, we are able to achieve minimal changing of the real DOM. 
        Types of change are: \texttt{CREATED, UPDATED, MOVED, DELETED}
    \end{description}

    In contrast with \facebook \react \texttt{Component}, our component provides only an API to a programmer.
    This class is the main class for a programmer using our library. 
    He doesn't need to use any other class created by our library. 
    Just some methods.

    We also have an inspiration from \react with idea of \textbf{virtual DOM}. 
    Vertices of an virtual DOM are represented by the class \texttt{Node} instead of the class \texttt{Component} to separate the functionality. 

    Each node contain an instance of \texttt{Component}. 
    The node represents the component in a virtual DOM.
    
    The diagram of relationships is shown on \fullref{img:library-core}. 
    In the next chapters we describe the main classes more in details.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.2]{images/uml/tiles/TilesCore/Core.png}
      \caption{Core of the library}
      \label{img:library-core}
    \end{figure}

    \subsubsection{Component}\label{subsubsec:our-architecture-core-component}
      The Component is the main building brick of application(library). 
      It offers api to the programmer with life-cycles, props etc. 

      Component is a class, which represents functionality of certain part of UI\footnote{UI = User Interface} in an application.
      It is created with some props and children acting as parameters of a function. 
      Main purpose of the component is to create a structure below\footnote{From the virtual DOM tree point of view} it, 
      add the event listeners and update itself based on event listener input.

      The main method of the \texttt{Component} is \texttt{List<ComponentDescription> render()}. 
      By this method component describes it's substructure.
      It will return list of children of this component, represented by instance of the class \texttt{ComponentDescription}. 
      \texttt{Node}, which owns this component (and called it's render method) will manage the rest.
      Basically, it will return the message like \textit{"This is how I should look like"}.

      Second important method is \texttt{void redraw()}, which trigger redraw of the component. 
      This redraw will be executed on the next animation frame. 

      Redraw is powered by \texttt{needUpdate} stream offered by \texttt{Component}, 
      which is automatically created in default constructor of class \texttt{Component}, 
      so it is very important, to call superclass constructor in each custom component class.

      \texttt{ComponentDescriptionFactory registerComponent(ComponentFactory factory)} is additional method helping programmer 
      for easier \texttt{ComponentDescription} creation. 
      Factories are described late in \fullref{sec:our-api}
      
    \subsubsection{DomComponent}\label{subsubsec:our-architecture-core-dom-component}
      \texttt{DomComponent} is a subclass of class \texttt{Component}. 
      This is specialized class, which represents HTML elements in the component structure.

      It has \texttt{props} saved as \texttt{Map}, because HTML element has attributes saved in \texttt{Map}.
      \texttt{render} method returns \texttt{children} member variable and \texttt{svg} and \texttt{pair} flags.

      Specific HTML elements are created based on different \texttt{ComponentFactory} and \texttt{ComponentDescriptionFactory}.
      \texttt{ComponentDescriptionFactory} is used to easily create \texttt{ComponentDescription}s of \texttt{DomComponent} in a custom component render method. 

    \subsubsection{ComponentDescription}\label{subsubsec:our-architecture-core-component-description}
      \texttt{ComponentDescription} is a description of the component. 
      It describes which type of the component should be rendered by using which parameters.

      For this purpose, it needs 4 types of information:
      \begin{itemize}
        \item \textbf{Type of the component} \hfill \\
          To create instance of a component, we need to know, what type (class) of the component it should be. 
          This information is represented by \texttt{ComponentFactory}, 
          which is function with 2 parameters, \texttt{props} and \texttt{children}, 
          which returns instance of a subclass of a \texttt{Component}.
        \item \textbf{Properties} \hfill \\
          Data which should be passed to the factory. 
          This data are used as a properties of the component.
        \item \textbf{Children} \hfill \\
          Children of described component.  
          This is useful mainly when programmer wants to render more complex structure of \texttt{DOMComponent}s.
        \item \textbf{Key} \hfill \\
          Key is an identifier of a child. 
          It is used to recognize reordering of children of the component.
          When components \texttt{render} method returns list of descriptions, 
          keys they contain are recognized and matched with keys stored in virtual DOM.

          If there is a match in key of the child in different position, child is only moved an updated. 
          If there is no match in key, default process follows.
      \end{itemize}

      Description is once created with all the parameters and then these parameters can't be changed. 
      All these parameters is set up by constructor. 

      \texttt{ComponentDescription} has one important method, which is \texttt{Component createComponent()}, 
      which creates \texttt{Component} instance with props and children from the description.

    \subsubsection{Node}\label{subsubsec:our-architecture-core-node}
      \texttt{Node} is the most important and complex class in the library.
      It providers following functionality:
      \begin{itemize}
        \item creates virtual DOM tree, maintains creating and updating of the tree based on results of component's \texttt{render} method, 
        \item listens to component's \texttt{needUpdate} stream and marks self as \textit{"dirty"} when it's component need update,
        \item and handles updating process that is rearranging children of the \texttt{Node}.
      \end{itemize}

      The node is also a vertex of the virtual DOM. 
      It store children as a list of children. 
      To use all possible optimization, node contain a \texttt{ComponentFactory} of the contained component, which is used when the virtual DOM is updated.
      It also contain \texttt{key} which is used to recognize changed position of the same child.

      Node has two important flags: \texttt{isDirty} and \texttt{hasDirtyDescendant}. 
      These flags represent information, whether the node, or its descendants, needs to be redrawn.
      If \texttt{isDirty} is true, the node needs to be updated, 
      because component of this node called \texttt{redraw} method.
      If \texttt{hasDirtyDescendant} is true,  
      there exist a descendant of this node, which wants to be updated.
      When \texttt{hasDirtyDescendant} is true and \texttt{isDirty} is false, 
      the node doesn't have to update itself, it is enough to call update on child nodes.

      Method \texttt{update({List<NodeChange> changes, bool force: false})} is executing the update process. 
      It take 2 named arguments:
      \begin{description}
        \item{\textbf{\texttt{List<NodeChange> changes}}} is used to be filled by changes generated by the update process,
        \item{\textbf{\texttt{bool force: false}}} is a flag signalizing if to update despite that node is not dirty.
      \end{description}

      The \texttt{update} method is used mostly in the browser part of an library, where it offers a possibility to get changes in the virtual DOM, which should be used to update the real one. 

      A methods logic consists of several main steps.
      \begin{enumerate}
        \item check, if update is needed by flags \texttt{isDirty}, \texttt{hasDirtyDescendant} or \texttt{force}, if no, exit,
        \item if component of this node needs to update (\texttt{isDirty == true}) or \texttt{force == true}, update this node with rearrangement of children,
        \item if any changes was generated, add them into the \texttt{changes} list
        \item set this node as not dirty and not have dirty descendant.
      \end{enumerate}

      The algorithm of rearrangement of children by calling \texttt{render} method of this component 
      and adapting node's children to returned descriptions is fully documented in the source code related to this work: 
      \url{https://github.com/cleandart/tiles/blob/master/lib/src/core/node_update_children.dart}

    \subsubsection{NodeChange}\label{subsubsec:our-architecture-core-node-change}
      \texttt{NodeChange} takes place as a record of a change in the virtual DOM. 
      It is used to mirror changes in the virtual DOM with the real DOM. 

      When some node in the virtual DOM is updated by method \texttt{update}, the list of changes is is collected.
      This list is subsequently processed by browser part of a library, which mirrors changes to the real DOM.

      \texttt{NodeChange} class has no methods (except constructor) and acts as a data chunk dedicated just for it's purpose. 
      It contains node, type of change, old and next properties. 

      Type is stored as an instance of \texttt{NodeChangeType} enum and can be one of: \texttt{CREATED}, \texttt{UPDATED}, 
      \texttt{MOVED} and \texttt{DELETED}. 
      When type is \texttt{UPDATED}, old props and new props take effect. 

  \subsection{Life-cycle}\label{subsec:our-architecture-lifecycle}

    Every instance of \texttt{Component} has its own life-cycle. 
    As every object, first it is created. 
    Subsequently, it is mounted and rendered into the virtual DOM, and then in to real DOM.

    When a "higher" node wants to update the node of the component, 
    the component will first receive props, 
    subsequently is asked if want to update, 
    if yes, it is asked for actual description of its children. 

    Sometimes the component wants to update itself (e.g. because event occurs).
    It calls redraw, then, it will be asked if really should update, and if yes, it is rendered and updated.

    At the end of component's life in the real DOM, 
    component should be notified about that.

    The whole life-cycle is shown on the \fullref{img:our-life-cycle}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.5]{images/uml/tiles/TilesCore/LifeCycle.png}
      \caption{Life cycle of a \texttt{Component}}
      \label{img:our-life-cycle}
    \end{figure}

    \subsubsection{Create}\label{subsec:our-architecture-lifecycle-create}

      The create part of life-cycle is implemented by constructor of \texttt{Component}. 
      It will receive props and optionally children as arguments and 
      it should prepare the whole state of object to live.

      An trivial example of constructor of \texttt{Component} is displayed below.
      \input{content/examples/my_component_constructor.tex}

      Constructor of an example only calls constructor of superclass \texttt{Component}.

      Example of more complex constructor should be e.g. the \texttt{Todo} component example:
      \input{content/examples/my_todo_component_constructor.tex}

    \subsubsection{Did mount}\label{subsec:our-architecture-lifecycle-didmount}

      When the component is mounted to the real DOM, user of the library should be notified about this event. 
      It is done by triggering the \textbf{Did mount} life-cycle event implemented the method \texttt{didMount}. 

      This is the place in time, were the component \textit{start to live its life} with the connection to the real DOM.
      This is the correct place to initialize for example the timers, stream listeners etc. 

      Our \texttt{MyTodoComponent} example compoent should listen for a change of the todo on the server, 
      and if it was changed, we can redraw the component.
      \input{content/examples/my_todo_component_didmount.tex}

    \subsubsection{Will receive props}\label{subsec:our-architecture-lifecycle-willreceiveprops}

      When the component is updated by "higher" ancestor, it will receive new props.
      A user of the library can need the possibility to compare these props with the old one
      and perform needed changes. 

      This is the correct place for subsequent life-cycle event \textit{Will receive props}
      implemented by the method \texttt{willReceiveProps}. 

      The example of \texttt{willReceiveProps} in \texttt{MyTodoComponent} 
      should compare the \texttt{todo} of the old and the new props and if they are not equal, 
      update change listener.
      \input{content/examples/my_todo_component_willreceiveprops.tex}
      
    \subsubsection{Should update}\label{subsec:our-architecture-lifecycle-shouldupdate}

      An optimization of the performance of an application can be done by rejecting "redraw" of the component.
      To reject this "redraw", component should be asked, if the redraw is needed. 

      This is implemented by the \texttt{shouldUpdate} method, which returns true if the component want to be redrawn. 

      By default \texttt{shouldUpdate} returns true, 
      what resolves to always updating of custom component, which doesn't implement this method.

      In a basic scenario this method recognize, 
      if the component will be rendered differently with the new props.  
      If not, it return false, else it return true.

      Example in \texttt{MyTodoComponent}:
      \input{content/examples/my_todo_component_shouldupdate.tex}

    \subsubsection{Render}\label{subsec:our-architecture-lifecycle-render}

      Render is the main part of the \texttt{Component}. 

      It is implemented by the method \texttt{render}.
      It should return array of component descriptions which should be considered as 
      \textit{"this is how this component should look like"}.

      For example, in our \texttt{MyTodoComponent} render will return \texttt{<div>} which contains title and description of \texttt{todo}.
      \input{content/examples/my_todo_component_render.tex}

    \subsubsection{Did update}\label{subsec:our-architecture-lifecycle-didupdate}

      When the life-cycle method \texttt{didUpdate}, 
      by which is implemented the  life-cycle \textit{"Did update"} event, 
      is triggered, the component is notified, 
      that it is mounted and there exist HTML elements in the DOM for each DomComponent descendant.

    \subsubsection{Will unmount}\label{subsec:our-architecture-lifecycle-willunmount}

      The \textit{"Will unmount"} event is implemented by the method \texttt{willUnmount}.
      It is called right before the component is removed from the virtual DOM and therefore from the real one. 
      This is the correct place to stop all timers and listeners.

      \input{content/examples/my_todo_component_willunmount.tex}

  \subsection{Rendering}\label{subsec:our-architecture-rendering}

    The main target of the \tiles library is the rendering of a content. 
    By the \texttt{Component} and the \texttt{Node} we can create the virtual DOM tree, 
    which should be reflected into the real one, or into the HTML markup string. 

    As we described earlier in the \fullref{subsec:our-architecture-structure}, 
    these rendering types are separated to separate packages from the core package and are independent from each other. 

    \subsubsection{Server side}\label{subsec:our-architecture-rendering-server}
      On the server, we don't have DOM elements available, 
      therefore we want to render our virtual DOM structure into the string
      representing HTML markup of the virtual and also the real DOM.

      The markup string constructed on the server can be reused in the browser to smooth user experience. 

      Our target, render virtual DOM into the markup string is not so complicated.
      From the programmers point of the view, 
      he will use a \texttt{ComponentDescription} to describe the component to be rendered.
      Our server-side package of the library will get the description and construct the node tree structure, 
      with node containing described component in the root. 
      The node tree represents the created virtual DOM. 

      From the virtual DOM we can render corresponding markup string by the depth-first search of it's tree. 
      The markup string is created recursively for every subtree starting from a node by this algorithm:

      \begin{algorithm}[H]
        \KwData{The node in virtual DOM tree}
        \KwResult{A string with the markup of the virtual DOM subtree with a root in the node}
        \eIf{the component of the node is DomComponent}{
          \eIf{the component is not pair}{
            write the markup into the result with attributes from the props and a tag name from the component\;
          }{
            write the open markup into the result with attributes from the props and a tag name from the component\;
            write the markup for all children recursively into the result\;
            write the close markup into the result\;
          }
        }{
          write the markup for all children recursively into the result\;
        }
        % }
        \caption{Write node into the markup string.}
      \end{algorithm}

    \subsubsection{In browser}\label{subsec:our-architecture-rendering-browser}

      The rendering in the browser is more difficult than the rendering into the markup string. 
      It is possible to use the same \textit{render to the markup string} method and add this markup to the DOM. 
      This will create DOM structure representing the virtual DOM, 
      but doesn't create connections between nodes in the virtual DOM and HTML elements in the real one. 
      This connections is necessary when the virtual DOM is updated.
      Therefore the browser side rendering will work in a different way. 

      \paragraph{Initial mount}\label{par:our-architecture-rendering-browser-init} 

        The first thing, the user of the library need to do, is to mount the component into the HTML element(\textit{mount root}). 
        For this purpose the \texttt{ComponentDescription} describing the component is used.
        The mount process consist from creation of the component from the description, 
        placing it into the node and first render of the virtual DOM with the root in the node. 

        The virtual DOM is subsequently reflected into the real DOM created under the \textit{mount root}.

        Suppose that the \textit{mount root} have no children 
        (the case of the \textit{mount root} with children is described in the \fullref{subsec:our-architecture-injecting},%\\
        the node mount process is described in the \fullref{algorithm:mount-node}:
        \begin{algorithm}[H]
          \KwData{The node in the virtual DOM and a HTML element, to mount the node to (mountRoot)}
          \KwResult{Mounted the node into the element}
          \eIf{the component of the node is DomComponent}{
            create an element representing the component\;
            add the created element to the mountRoot\;
            save relations between the created element and the node;

            \If{the component is a pair component}{
              \For{a child in children of the node}{
                mount the child node into the newly created element as a mountRoot\;
              }
            }
          }{
            \eIf{the component is a text component}{
              create a HTML text node with the text from the component\;
              add the text node to the mountRoot\;
              save relations between the created text node and the node;
            }{
              \For{a child in children of the node}{
                mount the child node into the mountRoot\;
              }
            }
          }
          % }
          \caption{Mount the component into the real DOM.}
          \label{algorithm:mount-node}
        \end{algorithm}

        The algorithm is recursive and skips custom components. 
        It creates relationships between created elements and nodes. 
        These relations is used to easy reflect the change in the virtual DOM into the real one 
        when the virtual DOM is changed.

        The DOM structure created by the \fullref{algorithm:mount-node} reflects the virtual DOM structure 
        with removed nodes with the custom component.

      \paragraph{Update}\label{par:our-architecture-rendering-browser-update} 
        
        As time goes, the situation, that the virtual DOM need to be updated, occurs. 
        The need of the update is realized by the method \texttt{redraw} of the component, 
        which cause marking the node as dirty.
        The framework recognize this situation and perform update of this node and the structure under it.
        The update produces a list of changes in the virtual DOM needed to be applied to the real DOM.

        Updates are processed by their type. 
        For every type the information about the HTML element representing a node is needed. 
        This information is stored in the relation \mbox{\texttt{Node $\rightarrow$ Element}}, 
        created in the mount of the node. 
        It is stored by \texttt{Map<Node, Element>}.

        What happened when we want to apply the node change into the real DOM structure differs by the type of the change:
        \begin{description}
          \item[CREATED] \hfill \\
            A newly created node is mounted into the DOM. 
            The adjusted \fullref{algorithm:mount-node} is used for this purpose.
          \item[UPDATED] \hfill \\
            If the node with a DOM component in it was updated, the element, related with it, is updated with the props of the node.
            If the node with a custom component was updated, no action is needed, because this node is not directly reflected to the DOM.
          \item[MOVED] \hfill \\
            The DOM representation of the moved node is moved to the new position.
          \item[DELETED] \hfill \\
            The DOM representation of the removed node is removed from the real DOM. 
        \end{description}

  \subsection{Events}\label{subsec:our-architecture-events}

    In the library which create own virtual DOM structure, it is natural to think about event in this virtual DOM. 
    As in the real one, it is natural to create event bubbling trough virtual DOM. 
    This synthetic event bubbling represents real event bubbling of the event 
    trough the real DOM elements associated with nodes in the virtual DOM.

    Synthetic event bubbling is useful for the user of the library to catch events in the DOM and react on them by update of the state 
    and triggering of the redraw of the component, if needed. 

    The \tiles library listen to DOM events on \textit{mount root} of the virtual DOM.
    When an event occur, the \tiles catch it on it's bubbling route up to he \texttt{body} element, 
    recognize, which node represents the target element of the event and start synthetic bubbling of the event from that node. 

    To store the relation \mbox{\texttt{Target Element $\rightarrow$ Node}} is used \texttt{Map<Element, Node>}.

    The \tiles library listen to every type of the event only once in the \textit{mount root} 
    of the virtual DOM for each event listened by components in it.

    It is important from the performance point of view, because we can add only one event listener for each event type in the whole virtual DOM.
    We will discuss this later in \fullref{chap:performance}.

    Synthetic event bubbling trough the virtual DOM enable to listen to the bubbled event even on custom component.

    \subsubsection{Synthetic bubbling}\label{subsec:our-architecture-events-bubbling}

      When the component is mounting, we store the relation between the HTML element, and the node, which contains this component. 
      Then we check a presence of the event listeners in the descriptions of the component. 
      We add event listener for every type of the event present in the virtual DOM to the \textit{mount root} HTML element. 
      The event listener in the \textit{mount root} is only one for each event type in the virtual DOM.

      When the event type listened by \textit{mount root} occurs in the DOM subtree representing our virtual DOM, 
      it will bubble up to the \textit{mount root}, where is caught by the event listener created by the \tiles library. 
      The \tiles library will recognize the target HTML element of the caught event 
      and simulate event bubbling from the node representing the target element in the virtual DOM.

      The synthetic bubbling process starts from the target node and check event listeners associated with it.
      If a listener for a type of the current event is presented, it is called with the event and the component as arguments. 

      The component is passed because the listener is not created by this component itself, 
      but by the component above it, which should be informed, on which component the listener was called.

      There is no official way of getting an information if the \texttt{stopPropagation} was called on the event.
      Therefore the listener, which want to stop a propagation, should return the \texttt{false} boolean.
      If the listener returns something else, bubbling continues with the parent of the current node.
      When the root node is achieved, the bubbling stops.

  \subsection{Injecting}\label{subsec:our-architecture-injecting}

    The \tiles library implement a built in server side rendering.

    It is important as for the SEO, so for the user experience. 
    User don't have to wait until the source code of the application is loaded into the browser and see the content of the page. 
    If our browser package replaces the structure generated on server with a new DOM structure 
    generated from virtual DOM, the part of the page is re-drawn from scratch,
    what cause disappearance of the content for the small amount of the time.

    To prevent this behavior, we created an injecting system, which will "inject" the existing DOM structure 
    and rebuild it to represent the virtual DOM.

    When the \texttt{ComponentDescription} is mounting, 
    basic implementation can erase whole content of element to which is the description mounted to.
    Instead, we will reuse the existing structure by iterating trough the virtual DOM and reusing every element, which match the virtual DOM. 
    The \tiles library iterate trough the virtual DOM and the real DOM simultaneously and compare them. 

    When the iteration trough the virtual DOM process a node with a DOM component and the HTML element,
    their tag names are compared.
    If tag names match, the HTML element is associated with the node, 
    element's attributes are adapted to the props of the node's component 
    and is used to mount/inject children of the node recursively.

    When the tag name don't match, 
    a new HTML element is inserted before the currently iterated element and paired with the node. 
    Subsequent DOM component at the same layer of the DOM component tree
    \footnote{
      By the DOM component tree we mean a derived tree from the virtual DOM tree, 
      which can be constructed by removing nodes with a custom component
      and connecting nodes with DOM components to the closest ancestor in the virtual DOM tree with a DOM component in it.
    }
    can reuse this not matching element.

    When injecting of children finishes for a node with a DOM component in it, 
    not used(injected) child HTML elements of the associated element are removed.

    This implementation of injecting enable a full reuse of the DOM structure created on the server.
    It also create relations important for future updates of the virtual DOM. 

    Moreover, if there exist a similar structure, not generated from same components on the server, 
    our library will reuse as much as possible of it.
\todo{End of the text refactoring}

\section{API}\label{sec:our-api}

  One product of this work is open source UI library.
  To use this library, user need to know the application programming interface(API) of it. 

  In \tiles library, user interface rendered by it consist of components, represented by the class \texttt{Component}. 
  This class is used to create functional logic of part of the UI. 

  To use it, mount it, add it to other component as a child, it is necessary to create \texttt{ComponentFactory}, 
  \texttt{ComponentDescription} and optionally \texttt{ComponentDescriptionFactory}.

  \textbf{\texttt{ComponentFactory}} is a function with two positional optional arguments \texttt{props} and \texttt{children}, 
  which return instance of the Component, ideally new with setted \texttt{props} and \texttt{children}.
  The easiest and most common way to create ComponentFacotry is shown in next example:
  \input{content/examples/component_factory.tex}

  \textbf{\texttt{ComponentDescription}} is something, what describes component. 
  It is used as argument to mounting functions and as result of \texttt{render} method.
  It is mostly not used directly, but by \texttt{ComponentDescriptionFactory}, 
  which is method with the same arguments as \texttt{ComponentFacotry}, and returns instance of \texttt{ComponentDescription}.

  It can be created by programmer himself, but mainly, it is created by \texttt{registerComponent} function, which accept one argument of \texttt{ComponentFacotry} type.
  This method created \texttt{ComponentDescriptionFactory}, which returns description with passed \texttt{ComponentFacotry}.
  Usage is shown on following example:
  \input{content/examples/register_component.tex}

  This \texttt{ComponentDescriptionFactory} is then used to create description or directly in mounting into HTML element:
  \input{content/examples/mount_component_description_factory.tex}

  \subsection{Component}\label{subsec:our-api-component}

    \texttt{Component} class is the main class of the API.
    Every custom component should extend or implement it. 

    It contains constructor, life-cycle methods, \texttt{render} and \texttt{redraw} method, props, children and offer \texttt{needUpdate} stream.
    The whole default \texttt{Component} is this: 
    \input{content/examples/component.tex}

    The easier way to create own component is by extending, not by implementing it, because extending add default functionality. 
    Simple component should look like this:
    \input{content/examples/my_component.tex}

    We can see, that this \texttt{MyComponent} only renders \texttt{ComponentDescription} of div DOM component which contain children with span description.
    \footnote{DOM component API will be discussed later.}

  \subsection{DOM component API}\label{subsec:our-api-dom}

    There are prepared \texttt{ComponentDescriptionFactory} functions for each of standard HTML elements, which gets standard arguments. 
    They will create new \texttt{ComponentDescription}, with correct factory, which created \texttt{DomComponent} with appropriate tag name.

    These factories can be used like on example of \texttt{MyComponent} in \texttt{render} function.

  \subsection{Browser specific API}\label{subsec:our-api-browser}
    
    There are 3 main addition when components are rendered in browser.
    \begin{itemize}
      \item Mounting
      \item References
      \item Event listeners
    \end{itemize}

    \textbf{Mounting} is implemented by \texttt{mountComponent} function, which have 2 arguments, 
    \texttt{ComponentDescription description} and \texttt{Element mountRoot}.
    It will mount described component into \texttt{mountRoot} element.
    \input{content/examples/mount_component_description_factory_only.tex}

    \textbf{References} are part of props. If component have in \texttt{props["ref"]} instance of internal class \texttt{{\textunderscore}Ref}, 
    which is only function returning void with one \texttt{Component} argument, then when this component is created and mounted, 
    this \texttt{{\textunderscore}Ref} is called with it. 

    It is useful, when some custom component want to have reference to element associated to some of it's descendant. 
    Example of usage is something like this:
    \input{content/examples/ref.tex}

    \textbf{Event listeners} are also represented as part of props. 
    They should be instance of \texttt{EventListener} class, which is function with 2 arguments, event and component and returns boolean.
    They are used in the same way as references, by adding to props with key in format \texttt{onEventType}:
    \input{content/examples/event_listener.tex}

  \subsection{Server specific API}\label{subsec:our-api-server}

    There is only one thing we want to do on the server, and that is to create markup for some \texttt{ComponentDescription}.
    For this purpose we created method \texttt{mountComponentToString}, which accepts 1 \texttt{ComponentDescription} argument and returns markup, 
    which is identical to what browser part of library should create in DOM.
    \input{content/examples/mount_component_to_string.tex}
