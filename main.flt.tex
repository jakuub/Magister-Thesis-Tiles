% flatex input: [main.tex]
\documentclass[oneside, 12pt]{book}
% \usepackage[slovak]{babel}
\usepackage{epsfig}
\usepackage{color}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{todonotes}
\usepackage{amsfonts}
\reversemarginpar
\usepackage[]{algorithm2e}

% flatex input: [./config.tex]

%------------------------------------------------------------------------------------------------------
% pekne pokope definujeme potrebne udaje
%------------------------------------------------------------------------------------------------------
\def\mftitle{Two-way databinding of models and views in Dart}          % nazov diplomovky/bakalarky
\def\mfthesistype{Diploma thesis}             % typ prace
\def\mfkeywords{Databinding, Dart, Facebook React, AngularJS, ... }        % proste klucove slova idealne oddelene ciarkou
\def\mfkeywordsen{Databinding, Dart, Facebook React, AngularJS, ... }      % klucove slova v anglictine EN
\def\mfkeywordssk{Databinding, Dart, Facebook React, AngularJS, ... }      % klucove slova v slovencine SK
\def\mfauthor{Bc. Jakub Uhrík}                            % vase meno a priezvysko
\def\mfadvisor{RNDr. Tomáš Kulich, PhD.}                                  % cele meno skolitela
\def\mfplacedate{Bratislava, 2014}                        % mesto a rok
\def\mfdate{2014}                                         % Rok
\def\mfuniversity{Comenius University in Bratislava}      % Univerzita
\def\mffakulta{Faculty of Mathematics, Physics and Informatics}  % Katedra
\def\mffakultafull{Faculty of Mathematics, Physics and Informatics, Comenius University in Bratislava}  
                                                          % Katedra v plnom zneni aj s univerzitou
\def\mfprogram{Computer Science}                               % studijny program
\def\mfodbor{9.2.1. Computer Science, Informatics}                            % studijny odbor
\def\mfpracovisko{FMFI.KI - Department of Computer Science}                    % skoliace pracovisko


% flatex input end: [./config.tex]

% \usepackage[slovak]{babel}

\usepackage[a4paper,vmargin={25mm,25mm},hmargin={35mm,20mm}]{geometry} 
\usepackage{minted}
\usepackage{caption}
\hyphenpenalty=10000
\tolerance=10000

\usepackage[
	bookmarks=true,
	bookmarksnumbered=false, 	% true means bookmarks in
								% left window are numbered
	bookmarksopen=false,
								% true means only level 1
								% are displayed.
	colorlinks=true,
	pdftitle={\mftitle},
	pdfauthor={\mfauthor},
	pdfsubject={\mfthesistype},
	pdfkeywords={\mfkeywords},
	pdfproducer={\mffakultafull},
	linkcolor=webblue]{hyperref}
\definecolor{webgreen}{rgb}{0, 0.5, 0} % less intense green
\definecolor{webblue}{rgb}{0, 0, 0.5} % less intense blue
\definecolor{webred}{rgb}{0.5, 0, 0}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{white}{rgb}{0.95, 0.95, 0.95}
\definecolor{black}{rgb}{0, 0, 0}
%------------------------------------------------------------------------------------------------------
% less intense red
%------------------------------------------------------------------------------------------------------

\usepackage[final]{pdfpages}

 
%------------------------------------------------------------------------------------------------------
% riadkovanie jeden a pol
%------------------------------------------------------------------------------------------------------
\renewcommand\baselinestretch{1.3} 

\def\phrase{\begingroup\phrasenohyphen
	\dononbreakablespace
	\dononbreakablehyphen
	\dophrase}
\makeatletter
\def\phrasenohyphen{%
	\language\@ifundefined{l@nohyphenation}{\@cclv}{\l@nohyphenation}}
\makeatother
\def\dophrase#1{#1\endgroup}

\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}

\author{\mfauthor}
\title{\mftitle}

\begin{document}

%------------------------------------------------------------------------------------------------------
% vlozime strukturu, vyplnte ju priamov suboroch, treba len pomenit texty
%------------------------------------------------------------------------------------------------------
% flatex input: [./content/structure/obalka.tex]
%------------------------------------------------------------------------------------------------------
%  toto je subor obalky vasej prace. 
%  s tymto by ste asi ani nemali nic robit pouziju sa prednastavene veci z hlavneho suboru
%------------------------------------------------------------------------------------------------------
\frontmatter

\thispagestyle{empty}

\noindent
\begin{center}
\begin{minipage}{0.8\textwidth}
\centerline{\renewcommand\baselinestretch{1.3} \LARGE\sc\mfuniversity}
\centerline{\sc\mffakulta}
\end{minipage}
\end{center}

\vfill
\begin{center}
\begin{minipage}{1\textwidth}
\bigskip\bigskip
\begin{center}
\linespread{1}\LARGE\sc\mftitle
\end{center}
\smallskip
\centerline{\mfthesistype}
\bigskip
\bigskip
\bigskip\bigskip
\end{minipage}
\end{center}
\vfill
{\bf\mfdate\\
\indent\mfauthor}
\eject 


% flatex input end: [./content/structure/obalka.tex]

%------------------------------------------------------------------------------------------------------

% flatex input: [./content/structure/titulka.tex]
%------------------------------------------------------------------------------------------------------
%  toto je titulna stranka, vsetky veci ste nastavili v config.tex
%------------------------------------------------------------------------------------------------------
\thispagestyle{empty}

\noindent
\begin{center}
\begin{minipage}{0.8\textwidth}
\centerline{\LARGE\sc\mfuniversity}
\centerline{\sc\mffakulta}
\end{minipage}
\end{center}

\vfill
\begin{center}
\begin{minipage}{1\textwidth}
\bigskip\bigskip
\begin{center}
\linespread{1}\LARGE\sc\mftitle
\end{center}
\smallskip
\centerline{\mfthesistype}
\bigskip
\bigskip
\bigskip\bigskip
\end{minipage}
\end{center}
\vfill
\begin{minipage}{0.8\textwidth}
\begin{tabular}{l l}
Study programme:& \mfprogram \\
Field of Study:& \mfodbor \\
Department:& \mfpracovisko\\
Thesis supervisor:&   \mfadvisor \\
\end{tabular}
\end{minipage}
\begin{center}
\end{center}
\vfill
{\bf\mfplacedate\\
\indent\mfauthor}
\eject 


% flatex input end: [./content/structure/titulka.tex]

%------------------------------------------------------------------------------------------------------

% flatex input: [./content/structure/zadanie.tex]
%------------------------------------------------------------------------------------------------------
%  pdf zadania dajte do zlozky images v subore zadanie.pdf tak ako vidite v prikaze. 
%  ak zadavate aj anglicke zadanie, odkomentujte(odstrante percento zo zaciatku) 
%  druhy riadok a podla neho pridajte adekvatne pdf
%------------------------------------------------------------------------------------------------------

\includepdf{images/zadanie-en.pdf}
\includepdf{images/zadanie.pdf}
% \includepdf{images/zadanie-en.pdf}


% flatex input end: [./content/structure/zadanie.tex]

%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% ked treba, da sa vlozit cestne prehlasenie...
%------------------------------------------------------------------------------------------------------
%\input{./content/structure/prehlasenie.tex}

% flatex input: [./content/structure/thanks.tex]
%------------------------------------------------------------------------------------------------------
% Podakovanie. Proste subor s podakovanim. Napiste sem komu dakujete, mozete sa inspirovat mojim
%------------------------------------------------------------------------------------------------------
{~}\vspace{12cm}

\noindent
\begin{minipage}{0.25\textwidth}~\end{minipage}
\begin{center}
\begin{minipage}{1\textwidth}
%------------------------------------------------------------------------------------------------------
%  sem pridajte svoj originalny text, alebo len prepiste \mfadvisor za vysklonovane meno vaseho veduceho
%------------------------------------------------------------------------------------------------------

I would like to thank my supervisor \mfadvisor for his guidance,support, and encouragement throughout writing this thesis. 

Special thanks belong to my family for all their support.

\end{minipage}
\end{center}
\hfill\mfauthor
\vfill\eject 


% flatex input end: [./content/structure/thanks.tex]

%\input{./content/structure/prehlasenie.tex}

% flatex input: [./content/structure/abstract.tex]
%------------------------------------------------------------------------------------------------------
% Toto je subor s abstraktom. Pridajte sem vas/tvoj abstrakt v slovencine a/alebo anglictine
% Ak chcete len jeden abstrakt, vymazte vsetko medzi komentarmi "jazyk zaciatok" a "jazy koniec"
%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% EN zaciatok
%------------------------------------------------------------------------------------------------------
\noindent
\begin{center}
\begin{minipage}{1\textwidth}
\centerline{\large Abstract}
Abstract in english.
%------------------------------------------------------------------------------------------------------
% sem pridajte abstrakt v anglictine
%------------------------------------------------------------------------------------------------------
\\ \\ 
{\bf Key words:} \mfkeywordsen
\end{minipage}
\end{center}
\eject % EOP v
%------------------------------------------------------------------------------------------------------
% EN konie
%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% SK zaciatok
%------------------------------------------------------------------------------------------------------
\noindent
\begin{center}
\begin{minipage}{1\textwidth}
\centerline{\large Abstrakt}
%------------------------------------------------------------------------------------------------------
% sem pridajte abstrakt v slovencine
%------------------------------------------------------------------------------------------------------
Abstrakt v slovencine.
\\ \\ 
{\bf Kľúčové slová:} \mfkeywordssk
\end{minipage}
\end{center}
\eject % EOP v
%------------------------------------------------------------------------------------------------------
% SK konie
%------------------------------------------------------------------------------------------------------


% flatex input end: [./content/structure/abstract.tex]

%\input{./content/structure/prehlasenie.tex}

%------------------------------------------------------------------------------------------------------
% obsah
%------------------------------------------------------------------------------------------------------
\tableofcontents

%------------------------------------------------------------------------------------------------------
% zoznam obrazkov
%------------------------------------------------------------------------------------------------------
\listoffigures

\mainmatter

%------------------------------------------------------------------------------------------------------
% page stype plain pre ciste strany bez cisiel stran pre uvod
%------------------------------------------------------------------------------------------------------
\pagestyle{plain}

%------------------------------------------------------------------------------------------------------
% a teraz includneme vsetky kapitoly, realne je to len subor, v ktorom sa incuduju kapitoly postupne
%------------------------------------------------------------------------------------------------------
% flatex input: [./content/chapters/chapters.tex]
\pagestyle{plain}
% flatex input: [content/chapters/intro.tex]
\chapter*{Introduction}\label{chap:intro}
\addcontentsline{toc}{chapter}{Introduction}

As one of the results of this magister thesis is our new databinding library in dart, 
which is called \textbf{tiles}. 
In next  text, we will use only \textbf{tiles} to mention \textit{our new databinding library in dart}.

% flatex input end: [content/chapters/intro.tex]

\pagestyle{headings}
% flatex input: [content/chapters/motivation.tex]
\chapter{Motivation}\label{chap:motivation}

The first question, as always should be, is the motivation of this work. 
What is the motivation to create another library, that will handle databinding in Dart?

The motivation to create the \textbf{tiles} library contains from several aspects, 
which are not contain in no other \texttt{Dart} library
\footnote{We didn't find any suitable library and didn't hear about it}.

\begin{description}
	\item[Dart as a programming language] \hfill \\
		Dart language is young programming language with an active development and progress. 
		One of its advantages is optional typing, 
		the build-in compilation to the JavaScript, which enable programming a browser applications,
		and a Java-like virtual machine, which runs the Dart in the most commonly used operating systems.

		It is designed for the web applications with all necessary support for them. 
		As it enable the compilation into the JavaScript and running directly under the OS, 
		it also enable to share a source code between server part of an application 
		and its client application running in the web browser.

		Dart also guarantees browser compatibility, what is important for ease of web application development.
	\item[Testability] \hfill \\
		Very important aspect in a building complex application is the testability of the source code.

		Because of this, it is essential to use libraries, which enables easy testing and mocking components.
	\item[Server side rendering] \hfill \\
		Server side rendering is very important for user experience and for search engine optimization. 

		When we have the CPM\footnote{Computer Programming Language} which can be used as on the server, so in the clients browser, 
		it is natural to think about a use of the same source code to create an in-browser application, 
		and to render its page on the server. 
	\item[No templates] \hfill \\
		This aspect is important from two point of views: the testability and the server side rendering.

		From the testability point of view, it is easier to test and mock structures created in only one CPM. 
		If the template is used to create a component of the UI, 
		it is much more difficult to test it and also think about this testing.
		If this component is only one class in the CPM without dependences on another type of the information, 
		testing is more natural and easier to think about.

		From the server side rendering point of view, if we want to work with templates, 
		we need to access them differently when we work in the OS and in the clients browser.
		If we have the structure fully composed in one CPM, it is easier to compose the same HTML structure on the server as in the browser, 
		then if we have the structure composed by the template and the CPM.
	\item[Only one language] \hfill \\
		This aspect is very related with the previous one. 
		When the application is created fully in one programming language, 
		it is easier for programmers to work with it (they don't have to switch between different CPM).

		Also it is easier to compile whole application into the JavaScript, analyze the source code or refactor it.
	\item[Reliability] \hfill \\
		The reliability has significant importance in complex applications. 
		This reliability can be achieved by automatic tests, a robust design and quality development. 
\end{description}

When we take into account these aspects, there exists no library, which fulfill all of them.

As there is a need for this kind of a library, we decided to design and create one. 

% flatex input end: [content/chapters/motivation.tex]

% flatex input: [content/chapters/databinding.tex]
\chapter{Databinding}\label{chap:databinding}

In this chapter we will introduce the area of databinding more deeply then in introduction.

\section{One way databinding}\label{sec:onewaydatabinding}

Discuss one way databinding.

\section{Two way databinding}

Discuss two way databinding.

% flatex input end: [content/chapters/databinding.tex]

% flatex input: [content/chapters/existing.tex]
\chapter{Existing solutions}\label{chap:existing}

When we think about the building of the user interfaces, we can think about the building them from components.
The component is a part of the UI, which has a functionality, own look and maybe some interaction.

The HTML is a basic component structure. Every element is a component, all elements are composed into tree structure. 
Elements have some functionality, own look(e.g. image) and some of them have interactions(e.g. input).

So when a library want to bind the data with a view, it basically bind the data to a component.

There are different approaches of the creating these components and the connection between them and a data. 
Components can be created directly by a programming language (Component driven), 
or by using a template engine, which create components based on the template, 
which describe component structure, in the most cases by HTML-like syntax(Template driven).

These two approaches do the same thing, create structure of the components, different way.

\section{Template driven}\label{sec:existing-template}

	Template driven approach is, as the name predicts, based on the usage of a template engine. 
	Template engines take a template and the data and create a component structure, 
	which is reflected into the HTML representation of passed data in the form of the template. 
	They can be considered as a function $t:\mathbb D\mapsto\mathbb H$, 
	where $\mathbb D$ is a set of all possible data and $\mathbb H$ is a context-free language of valid HTML.

	An easy example of a template, for example using \textit{handlebars.js} can look like this one (from \textit{handlebars.js} website):
  % flatex input: [content/examples/handlebars_entry.tex]
\begin{minted}{html+django}
<div class="entry">
  <h1>{{title}}</h1>
  <div class="body">
    {{body}}
  </div>
</div>
\end{minted}

% flatex input end: [content/examples/handlebars_entry.tex]


	When programmer want to use this template, he should create data object, which minimal version in JSON format is in next example:
  % flatex input: [content/examples/handlebars_entry_data.tex]
\begin{minted}{json}
{
  "title": "Some title",
  "body": "This is the content of the page"
}
\end{minted}

% flatex input end: [content/examples/handlebars_entry_data.tex]


	When template is filled by this data, following HTML will be produced
  % flatex input: [content/examples/handlebars_entry_result.tex]
\begin{minted}{html}
<div class="entry">
  <h1>Some title</h1>
  <div class="body">
    This is the content of the page
  </div>
</div>
\end{minted}

% flatex input end: [content/examples/handlebars_entry_result.tex]


	Most of template engines also offer logic markup, which add possibility of the better control of a composed structure. 
	This is highly usable when programmer want to create more complex structures based on the data. 
	The typical example of this structure is the \texttt{<ul>} list generated from the array of items to render.
	
	This "in template" logic has on one hand some advantages, on the other hand, 
	the HTML syntax was not created to represent a logic, but an information.
	Because of this, more complex templates witch not so trivial logic in it becomes hard to read and understand.
	
	Easy use of the logic in the template is shown on the next example:
  % flatex input: [content/examples/handlebars_logic.tex]
\begin{minted}{html+django}
<h1>Comments</h1>

<div id="comments">
  {{#each comments}}
  <div class="entry">
    {{#if author}}
      <h1>{{firstName}} {{lastName}}</h1>
    {{else}}
      <h1>Unknown Author</h1>
    {{/if}}
    <div>{{body}}</div>
  </div>
  {{/each}}
</div>

\end{minted}

% flatex input end: [content/examples/handlebars_logic.tex]


	The template driven view are highly used because of the syntax similarity between the template and the resulting HTML. 
	It is easy to convert the HTML produced by a graphic designer to the template used in the source code. 
	Also programmers used to work in the HTML more easily write templates then some other representation of the component structure.

	Different libraries work with templates in a different way. 
	Some of them really parse the input template as a string, recognize component tree in it and work with the template that way.
	Others uses in-browser HTML parser to parse the template and then fill it with the data.
	This approach, because of its usage of tools accessible only from the browser, is more difficult to render on the server.

	Templates are mostly used two different ways:
	\begin{description}
		\item[Template used as View] \hfill \\
			Template is used to render HTML structure into some element. 
			Functionality of the HTML structure is then realized separately and attached to it.  
			This is used for example in the CanJS.
		\item[Template used as Component] \hfill \\
			The other (and more modern) use of template is to represent one component with attached functionality, 
			which can be represented later as custom HTML element in other templates. 
			In this template, other custom components can be created by using their custom HTML element representation. 
			It is not necessary to create them separately in the code of an application.

			This approach is used e.g. in Polymer project, which work with so called "shadow DOM" which use similar concept.
	\end{description}

	\fullref{table:template-driven-libraries} compares some of existing solutions which are standalone libraries or MVC frameworks.
	The aspects of the comparison are a natural rendering in the browser and  on the server and if the library is a standalone UI library, 
	or is a part of the more complex MVC framework. 
	We don't compare a possibility to render the view on the server other then the natural way, 
	because it is always possible to render it by usage of tools like the \textit{PhantomJS}.

	\begin{table}
		\begin{tabular}{|l|l|c|c|c|c|}
			\hline
			\textbf{Solution}& \textbf{Language}   & \textbf{Standalone} & \textbf{In browser} & \textbf{On server} \\
			\hline
			handlebars       & JavaScript          &         yes         &        yes          &        yes         \\
			\hline
			{{mustache}}     & \shortstack{JavaScript,  
														\\		python...} &        yes         &        yes          &        yes          \\
			\hline
			dust             & JavaScript          &         yes         &        yes          &        yes         \\
			\hline
			AngularJS        & JavaScript          &         no          &        yes          &        no          \\
			\hline
			meteor           & JavaScript          &         no          &        yes          &        no          \\
			\hline
			EmberJS          & JavaScript          &         no          &        yes          &        yes         \\
			\hline
			Derby            & JavaScript          &         no          &        yes          &        yes         \\
			\hline
			Polymer          & JavaScript          &         yes         &        yes          &        no          \\
			\hline
			Polymer.dart     & Dart                &         yes         &        yes          &      not now       \\
			\hline
		\end{tabular}
		\caption{Comparison of template driven libraries}
		\label{table:template-driven-libraries}
	\end{table}

\section{Component driven}\label{sec:existing-component}

	Component driven views, in opposite to the template driven, don't use any additional type of data like templates. 
	Components are created by the same programming language as the functionality and 
	are composed into the tree structure which is mapped into the DOM. 

	When the tree of components (we will call it "Virtual DOM" later)is constructed, 
	it is rendered to the DOM by the depth-first search of the component tree.
	When components and HTML elements are connected by stored associations, 
	every change in the component structure can be applied to the DOM tree. 

	In addition, if we have the tree of components, we can easily, by the similar depth-first search, 
	create the markup string representing the HTML markup of the component tree.
	This enable the rendering of the whole component tree on the server without use of browser-specific features.

	An example of the component driven UI library is the JavaScript library \textit{React} created by the facebook.
  \textit{React} is standalone UI library which enable native rendering of the component structure as in the browser, so on the server.

	We decided to use a similar approach to \textit{React} library, so we briefly describe it.

	\subsection{React}\label{subsec:existing-component-react}
		
		\textit{React} is JavaScript UI library from facebook. 
		Its main concept is to pack parts of the web application into reusable components, 
		which are represented as object in JavaScript. 

		This components can be mounted into elements in DOM, for now, we will call it \textit{mount root}. 
		This will create \textit{virtual DOM} "mounted" to \textit{mount root}. 
		This virtual DOM is then reflexed into the real DOM under the \textit{mount root}.

		Components are organized to virtual DOM tree, where data flows from root component to leaves. 
		This data flow is implemented by props of the component, which are read-only.
		Component have also own state, which should be stored in state attribute and updated by methods \texttt{setState} and \texttt{replaceState}. 
		State shouldn't be updated directly to preserve invariant, that real DOM always represents actual state of the virtual one. 

		Component create structure under it by its method \texttt{render}, which should return one instance of a component, 
		which will be the child of this component.
		In render function, it can add to this rendered component props, which is the way, how data is flowing down, 
		and children, which is the way, how to create spreading tree, not just a line. 
		If the child component get children, it will be in \texttt{children} attribute. Component can reuse them in \texttt{render} method or ignore them.

		This is because \textit{React} maps all components to HTML elements and want to create more than one tree children only in components representing real DOM elements.

		Components can listen to events on the DOM components (internal react components, representing DOM elements). 
		They are attached trough props by event listeners. 

		When event occurs, it bubble up to \textit{mount root} where is caught by \textit{React}.
		Then \textit{React} simulate event bubbling from DOM component, which represents target element in virtual DOM,
		with synthetic event, which manage browser compatibility. 

		When this event is caught by some custom component, this component can react on that. 
		It can change state, call some functions, store some data or what ever it wants.

		State change(by mentioned methods) trigger redrawing of virtual DOM. 
		This will use render methods to create new children of the components 
		and process whole tree by depth-first search, 
		which produce list of changes needed to get real DOM to state representing virtual one.

		For this purpose, \textit{React} implements some component life-cycle methods, which we will not discuss here. 
		They are the superset of life-cycle methods we implement in Tiles library. 

		For more information about react and it's architecture and API 
		reader can go to the website of the \textit{React} project \url[http://facebook.github.io/react/]

\section{Conclusion}\label{sec:existing-conclusion}
		
\todo{Here should be described, why we decided to use component driven approach and take inspiration from \textit{React} library.}

% flatex input end: [content/chapters/existing.tex]

% flatex input: [content/chapters/our.tex]
\chapter{Our solution}\label{chap:oursolution}

We decided to use component-driven approach of databinding, 
because one of our main requirements is to be possible to render as on server, so in browser.
We decided to take inspiration from Facebook \textit{React} library, mainly in API of the library, which is component based, 
with some differences in architecture.

As we work in Dart language, which guarantees some browser compatibility and add some functionality that JavaScript doesn't have,
we don't have to implement some of \textit{React}'s additional features like:
\begin{itemize}
  \item Synthetic events \textit{(Dart unified events)}
  \item Mixins \textit{(Dart support native mixins as a part of a language)}
  \item Props type checking \textit{(Dart is optional-typed language)}
  \item Get default props and initial state \textit{(Dart work with classes which have constructors)}
  \item Changed class name \textit{(Map in dart use string, so string "class" is no more reserved word)}
  \item Test utilities \textit{(Dart has own unittest library and we work with classes and with native events, it is easily tested)}
\end{itemize}

In this next sections of this chapter we will introduce and deeply describe our Dart library \texttt{Tiles}.
\todo{Need decision, if write tiles with small or capital \textbf{T}}

\section{Requirements}\label{subsec:our-architecture-requirements}

  When we designed \texttt{Tiles} library, we take into account some basic requirements. 
  \begin{description}
    \item{\textbf{Rendering in both, browser and server}} \hfill \\
      One of the main advantages of this library is possibility to render the same content, 
      with the same code as on the server, so in the browser.
      This resolved into package architecture and several architectural decisions.
      \begin{description}
        \item{\textbf{No template usage}} \hfill \\
          To achieve possibility to render content on both, browser and server, 
          we decided not to use templates, 
          because to parse template into something independent from DOM is far more difficult,
          then just use own structure clearly in one programming language.
      \end{description}
    \item{\textbf{Easy to use API}} \hfill \\
      Solution can be very interesting and powerful, 
      but if it don't offer reasonably easy to use API, almost no one will use it.
      \begin{description}
				\item{\textbf{\textit{React}-like API}} \hfill \\
					Because we use similar concept as JavaScript library \textit{React},  
          which is widely used and known, 
          if we offer similar API, more people will more quickly get used to it.
      \end{description}
    \item{\textbf{Performance}} \hfill \\
      We want to offer useful library, and if want someone to use it, 
      we need to offer good performance in the competition of Dart and JavaScript UI libraries.
  \end{description}

  How we fulfilled these requirements is in detail described in next sections of this chapter.

\section{Architecture}\label{sec:our-architecture}

  In this section we describe our architecture from several points of view like 
	\nameref{subsec:our-architecture-overview}, 
  \nameref{subsec:our-architecture-structure}, 
  \nameref{subsec:our-architecture-core}, 
  \nameref{subsec:our-architecture-lifecycle}, 
  \nameref{subsec:our-architecture-events}, 
  \nameref{subsec:our-architecture-rendering} and
  \nameref{subsec:our-architecture-injecting}.

  We will focus on good understanding of how library works. 
  We will not discuss API a lot, this is the focus of next section. 

  But, of cause we add some examples, so wee will show some parts of api in this section too, 
  but they don't will be so much described as in next section.

  \subsection{Architectural overview}\label{subsec:our-architecture-overview}
	Our high level idea is based on facebook \textit{React} library attitude. 
    We created api, whose main class is \texttt{Component}, which represents construct very similar to react's \texttt{Component}.
    This component is mounted to an element, where it renders itself. 
    This relationship is described on \fullref{img:library-idea}.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/Idea.png}
      \caption{Idea}
      \label{img:library-idea}
    \end{figure}

    These components are placed into tree structure, which represents \mbox{\textbf{\nameref{img:library-idea-virtual-dom}}}, 
    which is then translated to the real DOM of client's browser or to the markup rendered by server application.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/IdeaObjects.png}
      \caption{Virtual DOM}
      \label{img:library-idea-virtual-dom}
    \end{figure}
    There can be the event listeners attached to these components. 
    The \textbf{events} \footnote{We work at Dart, which create browser compatibility for us, so we don't have to create synthetic events like react.}
    are then bubbled trough a virtual DOM, instead real one.
    By this there can be the listener attached to a custom component, which doesn't have element representing it in a real DOM.

    As we work in Dart language, it is natural to try to reuse the most of code on the both, client and server side.
    The next important part of idea is \textbf{server-side rendering}.
    which should do and easy rendering of the same content on server as on the client's browser.
    It is very important for SEO purposes and smooth user experience. 

  \subsection{Structure}\label{subsec:our-architecture-structure}

    We split our library into 3 partially dependent packages. 
    \begin{description}
      \item[Tiles] \hfill \\
        \textbf{Tiles} package creates the core component's of library, focused to create and maintain virtual DOM and provide API for programmer.
        This package should be included by programmer in the files, where he defines custom components. 
        These components then can be used on both, server and browser sides.
      \item[Tiles Browser] \hfill \\
        This package is used for mounting components to the HTML elements. 
        It maintains relationships between elements and components, 
        simulates events bubbling and keeps real DOM in sync with virtual one.
      \item[Tiles Server] \hfill \\
        \textbf{Tiles Server} package maintains server-side rendering. It offers an API to render component structure to string with markup based on DOM components.
    \end{description}

    Based on the mentioned packages structure, it is quiet obvious what are the dependences between these packages.
    \texttt{\textbf{Tiles}} package is independent, 
		and both of \texttt{\textbf{Tiles Browser}} and \texttt{\textbf{Tiles Server}} are dependent on \texttt{\textbf{Tiles}} package.
    These dependences are shown on \fullref{img:library-packages}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Packages.png}
      \caption{Packages}
      \label{img:library-packages}
    \end{figure}

  \subsection{Core}\label{subsec:our-architecture-core}
    There are 4 main classes in the core of the library.
    \begin{description}
      \item[Component] 
        represents closed block of user interface, 
        that should be rendered in application.
      \item[Node]
        is a vertex in a tree of virtual DOM. 
        It contains an instance of \texttt[Component], which represents the type of this \texttt{Node}.
      \item[ComponentDescription]
        is self-explanatory. 
        It is returned from the component to describe it's children. 
				The principles are described later at this document.
      \item[NodeChange]
        represents one change in a virtual DOM, which should be applied into the real DOM. 
        This way, we are able to achieve minimal changing of the real DOM. 
        Types of change are: \texttt{CREATED, UPDATED, MOVED, DELETED}
    \end{description}

		In contrast with facebook \textit{React} \texttt{Component}, our component provides only an API to a programmer.
    This class is the main class for a programmer using our library. 
		He doesn't need to use any other class created by our library. 
    Just some methods.

		We also have an inspiration from \textit{React} with idea of \textbf{virtual DOM}. 
		Vertices of an virtual DOM are represented by the class \texttt{Node} instead of the class \texttt{Component} to separate the functionality. 

    Each node contain an instance of \texttt{Component}. 
		The node represents the component in a virtual DOM.
    
    The diagram of relationships is shown on \fullref{img:library-core}. 
		In the next chapters we describe the main classes more in details.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.2]{images/uml/tiles/TilesCore/Core.png}
      \caption{Core of the library}
      \label{img:library-core}
    \end{figure}

    \subsubsection{Component}\label{subsubsec:our-architecture-core-component}
      The Component is the main building brick of application(library). 
      It offers api to the programmer with life-cycles, props etc. 

      Component is a class, which represents functionality of certain part of UI\footnote{UI = User Interface} in an application.
      It is created with some props and children acting as parameters of a function. 
      Main purpose of the component is to create a structure below\footnote{From the virtual DOM tree point of view} it, 
      add the event listeners and update itself based on event listener input.

      The main method of the \texttt{Component} is \texttt{List<ComponentDescription> render()}. 
      By this method component describes it's substructure.
      It will return list of children of this component, represented by instance of the class \texttt{ComponentDescription}. 
      \texttt{Node}, which owns this component (and called it's render method) will manage the rest.
      Basically, it will return the message like \textit{"This is how I should look like"}.

      Second important method is \texttt{void redraw()}, which trigger redraw of the component. 
      This redraw will be executed on the next animation frame. 

      Redraw is powered by \texttt{needUpdate} stream offered by \texttt{Component}, 
      which is automatically created in default constructor of class \texttt{Component}, 
      so it is very important, to call superclass constructor in each custom component class.

			\texttt{ComponentDescriptionFactory registerComponent(ComponentFactory factory)} is additional method helping programmer 
			for easier \texttt{ComponentDescription} creation. 
			Factories are described late in \fullref{sec:our-api}
      
    \subsubsection{DomComponent}\label{subsubsec:our-architecture-core-dom-component}
      \texttt{DomComponent} is a subclass of class \texttt{Component}. 
      This is specialized class, which represents HTML elements in the component structure.

      It has \texttt{props} saved as \texttt{Map}, because HTML element has attributes saved in \texttt{Map}.
      \texttt{render} method returns \texttt{children} member variable and \texttt{svg} and \texttt{pair} flags.

      Specific HTML elements are created based on different \texttt{ComponentFactory} and \texttt{ComponentDescriptionFactory}.
      \texttt{ComponentDescriptionFactory} is used to easily create \texttt{ComponentDescription}s of \texttt{DomComponent} in a custom component render method. 

    \subsubsection{ComponentDescription}\label{subsubsec:our-architecture-core-component-description}
      \texttt{ComponentDescription} is a description of the component. 
      It describes which type of the component should be rendered by using which parameters.

      For this purpose, it needs 4 types of information:
      \begin{itemize}
        \item \textbf{Type of the component} \hfill \\
          To create instance of a component, we need to know, what type (class) of the component it should be. 
          This information is represented by \texttt{ComponentFactory}, 
          which is function with 2 parameters, \texttt{props} and \texttt{children}, 
          which returns instance of a subclass of a \texttt{Component}.
        \item \textbf{Properties} \hfill \\
          Data which should be passed to the factory. 
					This data are used as a properties of the component.
        \item \textbf{Children} \hfill \\
          Children of described component.  
          This is useful mainly when programmer wants to render more complex structure of \texttt{DOMComponent}s.
        \item \textbf{Key} \hfill \\
					Key is an identifier of a child. 
					It is used to recognize reordering of children of the component.
					When components \texttt{render} method returns list of descriptions, 
					keys they contain are recognized and matched with keys stored in virtual DOM.

					If there is a match in key of the child in different position, child is only moved an updated. 
					If there is no match in key, default process follows.
      \end{itemize}

			Description is once created with all the parameters and then these parameters can't be changed. 
      All these parameters is set up by constructor. 

      \texttt{ComponentDescription} has one important method, which is \texttt{Component createComponent()}, 
      which creates \texttt{Component} instance with props and children from the description.

    \subsubsection{Node}\label{subsubsec:our-architecture-core-node}
      \texttt{Node} is the most important and complex class in the library.
      It providers following functionality:
			\begin{itemize}
				\item creates virtual DOM tree, maintains creating and updating of the tree based on results of component's \texttt{render} method, 
				\item listens to component's \texttt{needUpdate} stream and marks self as \textit{"dirty"} when it's component need update,
				\item and handles updating process that is rearranging children of the \texttt{Node}.
			\end{itemize}

			The node is also a vertex of the virtual DOM. 
			It store children as a list of children. 
			To use all possible optimization, node contain a \texttt{ComponentFactory} of the contained component, which is used when the virtual DOM is updated.
			It also contain \texttt{key} which is used to recognize changed position of the same child.

      Node has two important flags: \texttt{isDirty} and \texttt{hasDirtyDescendant}. 
      These flags represent information, whether the node, or its descendants, needs to be redrawn.
      If \texttt{isDirty} is true, the node needs to be updated, 
      because component of this node called \texttt{redraw} method.
      If \texttt{hasDirtyDescendant} is true,  
      there exist a descendant of this node, which wants to be updated.
      When \texttt{hasDirtyDescendant} is true and \texttt{isDirty} is false, 
      the node doesn't have to update itself, it is enough to call update on child nodes.

			Method \texttt{update({List<NodeChange> changes, bool force: false})} is executing the update process. 
			It take 2 named arguments:
			\begin{description}
				\item{\textbf{\texttt{List<NodeChange> changes}}} is used to be filled by changes generated by the update process,
				\item{\textbf{\texttt{bool force: false}}} is a flag signalizing if to update despite that node is not dirty.
			\end{description}

			The \texttt{update} method is used mostly in the browser part of an library, where it offers a possibility to get changes in the virtual DOM, which should be used to update the real one. 

      A methods logic consists of several main steps.
      \begin{enumerate}
				\item check, if update is needed by flags \texttt{isDirty}, \texttt{hasDirtyDescendant} or \texttt{force}, if no, exit,
				\item if component of this node needs to update (\texttt{isDirty == true}) or \texttt{force == true}, update this node with rearrangement of children,
				\item if any changes was generated, add them into the \texttt{changes} list
        \item set this node as not dirty and not have dirty descendant.
      \end{enumerate}

      The algorithm of rearrangement of children by calling \texttt{render} method of this component 
      and adapting node's children to returned descriptions is fully documented in the source code related to this work: 
      \url{https://github.com/cleandart/tiles/blob/master/lib/src/core/node_update_children.dart}

    \subsubsection{NodeChange}\label{subsubsec:our-architecture-core-node-change}
      \texttt{NodeChange} takes place as a record of a change in the virtual DOM. 
      It is used to mirror changes in the virtual DOM with the real DOM. 

			When some node in the virtual DOM is updated by method \texttt{update}, the list of changes is is collected.
      This list is subsequently processed by browser part of a library, which mirrors changes to the real DOM.

      \texttt{NodeChange} class has no methods (except constructor) and acts as a data chunk dedicated just for it's purpose. 
      It contains node, type of change, old and next properties. 

      Type is stored as an instance of \texttt{NodeChangeType} enum and can be one of: \texttt{CREATED}, \texttt{UPDATED}, 
      \texttt{MOVED} and \texttt{DELETED}. 
      When type is \texttt{UPDATED}, old props and new props take effect. 

  \subsection{Life-cycle}\label{subsec:our-architecture-lifecycle}

    Every instance of \texttt{Component} has its own life-cycle. 
    As every object, first it is created. 
    Subsequently, it is mounted and rendered into the virtual DOM, and then in to real DOM.

    When a "higher" node wants to update the node of the component, 
		the component will first receive props, 
		subsequently is asked if want to update, 
		if yes, it is asked for actual description of its children. 

    Sometimes the component wants to update itself (e.g. because event occurs).
    It calls redraw, then, it will be asked if really should update, and if yes, it is rendered and updated.

    At the end of component's life in the real DOM, 
    component should be notified about that.

    The whole life-cycle is shown on the \fullref{img:our-life-cycle}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.5]{images/uml/tiles/TilesCore/LifeCycle.png}
      \caption{Life cycle of a \texttt{Component}}
      \label{img:our-life-cycle}
    \end{figure}

    \subsubsection{Create}\label{subsec:our-architecture-lifecycle-create}

      The create part of life-cycle is implemented by constructor of \texttt{Component}. 
      It will receive props and optionally children as arguments and 
      it should prepare the whole state of object to live.

      An trivial example of constructor of \texttt{Component} is displayed below.
      % flatex input: [content/examples/my_component_constructor.tex]
      \begin{minted}{dart}
class MyComponent extends Component {
  MyComponent(props, [children]): super(props, children) {}
}
      \end{minted}

% flatex input end: [content/examples/my_component_constructor.tex]


      Constructor of an example only calls constructor of superclass \texttt{Component}.

      Example of more complex constructor should be e.g. the \texttt{Todo} component example:
      % flatex input: [content/examples/my_todo_component_constructor.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  MySearchComponent(props, [children]): super(props, children) {
    if (props != null && props.todo is Todo) {
      this.todo = props.todo
    } else {
      this.todo = new Todo();
    }
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_constructor.tex]


    \subsubsection{Did mount}\label{subsec:our-architecture-lifecycle-didmount}

			When the component is mounted to the real DOM, user of the library should be notified about this event. 
			It is done by triggering the \textbf{Did mount} life-cycle event implemented the method \texttt{didMount}. 

			This is the place in time, were the component \textit{start to live its life} with the connection to the real DOM.
      This is the correct place to initialize for example the timers, stream listeners etc. 

      Our \texttt{MyTodoComponent} example compoent should listen for a change of the todo on the server, 
      and if it was changed, we can redraw the component.
      % flatex input: [content/examples/my_todo_component_didmount.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  didMount() {
    this.subscription = this.todo.changedOnServer.listen((change) {
      this.redraw();
    });
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_didmount.tex]


    \subsubsection{Will receive props}\label{subsec:our-architecture-lifecycle-willreceiveprops}

			When the component is updated by "higher" ancestor, it will receive new props.
			A user of the library can need the possibility to compare these props with the old one
			and perform needed changes. 

			This is the correct place for subsequent life-cycle event \textit{Will receive props}
      implemented by the method \texttt{willReceiveProps}. 

      The example of \texttt{willReceiveProps} in \texttt{MyTodoComponent} 
      should compare the \texttt{todo} of the old and the new props and if they are not equal, 
      update change listener.
      % flatex input: [content/examples/my_todo_component_willreceiveprops.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  willReceiveProps(dynamic newProps) {
    if (this.todo != newProps.todo) {
      this.subscription.cancel();
      this.subscription = newProps.todo.changedOnServer.listen((change) {
        this.redraw();
      });
    }
  }

  // ...
}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_willreceiveprops.tex]

      
    \subsubsection{Should update}\label{subsec:our-architecture-lifecycle-shouldupdate}

			An optimization of the performance of an application can be done by rejecting "redraw" of the component.
			To reject this "redraw", component should be asked, if the redraw is needed. 

			This is implemented by the \texttt{shouldUpdate} method, which returns true if the component want to be redrawn. 

			By default \texttt{shouldUpdate} returns true, 
      what resolves to always updating of custom component, which doesn't implement this method.

      In a basic scenario this method recognize, 
      if the component will be rendered differently with the new props.  
      If not, it return false, else it return true.

      Example in \texttt{MyTodoComponent}:
      % flatex input: [content/examples/my_todo_component_shouldupdate.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  shouldUpdate (newProps, oldProps) {
    if (newProps.todo == oldProps.todo) {
      return false;
    }
    return true;
  }

  // ...

}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_shouldupdate.tex]


			\todo{End of the text refactoring}

    \subsubsection{Render}\label{subsec:our-architecture-lifecycle-render}

      Render is the main part of the \texttt{Component}. 

      It is implemented by method \texttt{render}, which have no attributes.
      It should return array of component descriptions which should be considered as 
      \textit{"this is how this component should look like"}.

      For example, in our \texttt{MyTodoComponent} render will return \texttt{<div>} which contains title and description of \texttt{todo}.
      % flatex input: [content/examples/my_todo_component_render.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  render () {
    return div ({"class": "todo"}, [
      h2 ({}, todo.title),
      p ({}, todo.description)
    ]);
  }

  // ...

}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_render.tex]


    \subsubsection{Did update}\label{subsec:our-architecture-lifecycle-didupdate}

      When life-cycle method \texttt{didUpdate}, 
      by which is implemented this life-cycle event, 
      is triggered, component, and programmer, can be sure, 
      that component is mounted and there exist elements in DOM for each DomComponent descendant.

    \subsubsection{Will unmount}\label{subsec:our-architecture-lifecycle-willunmount}

      This event is implemented by method \texttt{willUnmount}, which contain no arguments.
      
      It is called right before it is unmounted from dom. 

      This is the correct place to stop all timers and listeners.
      % flatex input: [content/examples/my_todo_component_willunmount.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  willUnmount () {
    subscription.cancel();
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_willunmount.tex]


  \subsection{Rendering}\label{subsec:our-architecture-rendering}
    The main target of our library is rendering of a content. 
    By \texttt{Component} and \texttt{Node} we can create virtual DOM tree, 
    but now we want to render this structure into something independent from our library. 

    As our work is in the scope of web applications, we want to render it into DOM (browser rendering), 
    and also into textual representation of a DOM(server rendering).

    As we described earlier in \fullref{subsec:our-architecture-structure}, 
    these rendering types are separated to separate packages from the core package and are independent from each other. 

    \subsubsection{Server side}\label{subsec:our-architecture-rendering-server}
      On the server, we don't have DOM elements available, 
      because of that we want to render our virtual DOM structure into a string,
      which user of this library can return as a response to browser request.

      When we have string, which represents markup of DOM created from virtual DOM, 
      created by our library, we can do server-side databinding, 
      which can be reuse in the browser to smooth user experience. 

      Our target, render virtual DOM into markup string is quiet easy.
      From the programmers point of view, he will use \texttt{ComponentDescription} to describe, 
      what component he want to render. 
      Our server-side package of library will get this description, creates component from it, 
      puts it into node and perform update of node. 
      By this, virtual DOM is created. 

      Now, as we have virtual DOM, we can render it's markup by depth-first search of it's tree. 
      In the search, when we came into node, we will do something like this algorithm (pseudo-code):
      \begin{algorithm}[H]
        \KwData{node in virtual DOM}
        \KwResult{String with markup of subtree of virtual DOM with root in setted node}
        % initialization\;
        % \While{not at end of this document}{
        % read current\;
        \eIf{component is DomComponent}{
          \eIf{component is not pair}{
            write markup with attributes from props\;
          }{
            write open markup\;
            write markup for all children recursively\;
            write close markup\;
          }
        }{
          write markup for all children recursively\;
        }
        % }
        \caption{Write node into string.}
      \end{algorithm}

    \subsubsection{In browser}\label{subsec:our-architecture-rendering-browser}
      Rendering in browser is quiet more difficult than rendering to string. 
      We can use same render to string method, but we will need some connections between nodes and elements, 
      so we can't do it this simply.

      \paragraph{Initial mount}\label{par:our-architecture-rendering-browser-init} 
        First the user of the library need to do is to mount component to the HTML element. 
        Of cause, he will mount component description, not component directly.
        When component is mounting, it is created, placed into the node and after this, node is "updated". 
        It is initial update which creates virtual DOM. 

        When virtual DOM is created, we need to construct real DOM under the root element 
        (element, which was component mounted to) from "virtual image".

        For now, we describe case, that root element is empty (has no child element or node).
        Case, when it is not empty we discussed in the \fullref{subsec:our-architecture-injecting}.
        The mount is easily described by next algorithm:
        \begin{algorithm}[H]
          \KwData{node in virtual DOM and HTML element, to mount node to (mountRoot)}
          \KwResult{Mounted node into element}
          % initialization\;
          % \While{not at end of this document}{
          % read current\;
          \eIf{node.component is DomComponent}{
            \eIf{node.component is not pair}{
              create element representing component\;
              add created element to mountRoot\;
            }{
              create element representing component\;
              add created element to mountRoot\;
              \For{child in node.children} {
                run recursively with created element as mountRoot and child as node\;
              }
            }
            save relations between created element and node;
          }{
            \eIf{node.component is tex component}{
              create HTML text node with text from component\;
              add text node to mountRoot\;
              save relations between created text node and node;
            }{
              \For{child in node.children} {
                run recursively with mountRoot and child as node\;
              }
            }
          }
          % }
          \caption{Write node into string.}
        \end{algorithm}

        As we can see, algorithm is recursive and skips custom components. 
        Also it creates relations between created elements and nodes. 
        Which are these relations we discuss later, when we need them.

        By this algorithm, it is obvious, that we have real DOM with the same structure, 
        if we can obtain from virtual DOM by removing nodes with custom components 
        and connect their children with their parent.

      \paragraph{Update}\label{par:our-architecture-rendering-browser-update} 
        Later, there can be situation, that virtual DOM want to be updated. 
        This is when some node was marked as \textit{dirty}.
        Then framework perform update of this node, 
        which triggers update of the subtrees with roots in dirty nodes.
        This updates return lists of changes in virtual DOM, 
        which should be applied to browser element structure.

        These updates should be processed by it's type. 
        But for every type we need the information about which HTML element represents some node. 
        This is first relation, which we need to remember, when we initialize mounted relation, 
        relation \mbox{\texttt{Node $\rightarrow$ Element}}. 
        This relation is stored by map \texttt{Map<Node, Element>}.

        But what happened when we want to apply node change into real DOM structure?
        For each type of change something different of cause:
        \begin{description}
          \item[CREATED]
            when new node is created, it should be mounted into the DOM. 
            If it has \texttt{DomComponent} inside, HTML element will be created and placed at the correct place. 
            If it has some custom component, this change will be ignored. 
          \item[UPDATED]
            If node was updated, then if it has \texttt{DomComponent}, it's element is updated with setted props.
          \item[MOVED]
            Node or it's children(if it is node with custom component) is moved to new position.
          \item[DELETED]
            Element of node or elements of its descendants(if it is node with custom component) are removed from DOM.
        \end{description}

  \subsection{Events}\label{subsec:our-architecture-events}
    As we were created dart library which creates virtual DOM, composed from nodes, which contains components, 
    it is obvious that we can "simulate" event bubbling trough this virtual DOM. 

    This is useful to offer user of library possibility to catch events in DOM and react on them by update of state 
    and triggering of redraw of the component, if needed. So the question is, how add this possibility to programmer.

    It is important from performance point of view, because by this, we can add only one event listener for each event type in whole virtual DOM.
    We will discuss this later in \fullref{chap:performance}.

    To enable this synthetic bubbling, we need to find out, which component belongs to element on which was event triggered.

    We maintain relationship between nodes, components and HTML elements, so we can store this relations.
    By these relations we can listen to all events on root HTML element 
    (element, which is whole our virtual DOM mounted to), 
    and then, by stored relations mentioned above, assign DOM component to element on which was event triggered.

    When we have this component, we can simulate bubbling of event trough our virtual DOM. 
    This brings opportunity to "listen to events" on custom components. 
    But this is really questionable feature.

    If custom component automatically "listen to events" if have event listener in props, 
    it enable programmer to listen to event on, for example, custom button which is composed from more child DOM components.
    But this is additional functionality of DOM, which don't have to be desirable. 

    On the other hand, if custom component don't automatically listens to event, props, it will lighten library from functionality, 
    component will not have some additional functionality from that, which is created by programmer, 
    and in addition, it is easily possible component, to pass event listener, which it got from props, some of it's child components.
    
    We decided to \textbf{ADD WHAT WE DECIDED TO DO}.\todo{decide, and add decision here}

    Now, we will describe, how these synthetic event bubbling works.

    \subsubsection{Synthetic bubbling}\label{subsec:our-architecture-events-bubbling}

      When component is mounting, we store relation between HTML element, and node, which contain this component. 
      Then we check, if this component have event listeners in it. 
      If it has, we add event listener of the same event type to root HTML element, 
      which is associated to root node of virtual DOM. 
      Of cause, we will add only one listener of one event type to this element, 
      although when there is more then one descendant, which "listens" to this event type.

      Then, when this type of event occurs in HTML DOM subtree which represents our virtual DOM, 
      it will bubble up to the root HTML element, there it is caught by our event listener. 
      This event listener will recognize on which HTML element was event triggered, 
      find representing node in virtual DOM, and start "bubbling" from it.

      Bubbling is done by checking if component of this node have event listener for this type of event in it's props.
      If it contain it, listener is called with event and components as arguments. 

      We pass component as an argument because this listener is not created by this component itself, 
      but by component above it, and it should be informed, on which component this listener was called.

      If this listener didn't returns \texttt{false}, bubbling continues to parent node. 
      When root is achieved, bubbling stops and real event listener, 
      which simulate internal event bubbling, ends.

      There exist better solution for stopping synthetic event bubbling then returning false from event listener 
      by calling \texttt{stopPropagation} method on event, which stop bubbling in real DOM. 
      But there exist no official way of getting this information from event object. 

      This is resolvable, in multiple ways. For example, by creating "synthetic" event
      which should encapsulate real event object and store information that \texttt{stopPropagation} was called.
      But this solution creates some problems, e.g. multiple types of events in dart, 
      represented by different classes with not the same api.
      Because of this, we decided to not add this ideal functionality for now, while there not exists official way this information from event object.

      Other solution, and in our opinion best one, 
      is to add official way of getting information if \texttt{stopPropagation} was called to core Dart \texttt{Event} class.
      But this is out of the scope of our library, so we created feature request to Dart developers and hope they will implement it.

  \subsection{Injecting}\label{subsec:our-architecture-injecting}

    We added possibility to render whole HTML structure on server and add it to requested HTML.

    This is good for user experience, because user of the application can see the result of his request event before JavaScript/Dart is loaded.
    But if our browser package replace this structure with new DOM structure, 
    generated from virtual DOM, it should be annoying for user of the application, because the part of the page, 
    which is represented by virtual DOM, will disappear for a short time and then appear back in the same look. 

    To prevent this, we created injecting system, which will inject existing DOM structure and rebuild it to represent virtual DOM.

    When the \texttt{ComponentDescription} is mounting, basic implementation can erase whole content of element to which is description mounted to.
    Instead of this, we will reuse existing structure by iterating trough virtual DOM and reusing every element, which match virtual DOM. 

    When we iterate trough virtual DOM and get to node with DOM component, we will look at the currently processed HTML element.
    If it match the type of DOM component (by tag name), 
    it is associated with this node, 
    adapted to represent it in real DOM\footnote{By changing attributes to correct state}, 
    used to mount children of this node under it with the same process recursively,
    and processing of elements move to next sibling of current element.

    When current element don't match type of DOM component, 
    new HTML element is inserted before it and paired with this node. 
    By this, other DOM component at the same layer of the DOM component tree
    \footnote{
      By DOM component tree we mean derived tree from virtual DOM tree, 
      which can be constructed by removing nodes with custom components
      and connecting nodes with DOM components to closest ancestor in virtual DOM tree with DOM component in it.
    }
    can reuse this not matching element.
    When one layer of the DOM component tree is finished
    (which is when iteration go to the node, which contain DOM component associated with parent HTML element),
    rest of the original HTML elements in this layer of DOM is erased. 

    By these simple and lightweight comparisons, if the html was created by the same components with the same data on server, 
    library will reuse whole html with no change and inject needed relations to the virtual DOM to the real one. 

    Moreover if there exist some similar structure, not generated by same components on the server, 
    our library will reuse as much as possible with not too complex and heavy comparison machinery.

\section{API}\label{sec:our-api}

  One product of this work is open source UI library.
  To use this library, user need to know the application programming interface(API) of it. 

  In \texttt{tiles} library, user interface rendered by it consist of components, represented by the class \texttt{Component}. 
  This class is used to create functional logic of part of the UI. 

  To use it, mount it, add it to other component as a child, it is necessary to create \texttt{ComponentFactory}, 
  \texttt{ComponentDescription} and optionally \texttt{ComponentDescriptionFactory}.

  \textbf{\texttt{ComponentFactory}} is a function with two positional optional arguments \texttt{props} and \texttt{children}, 
  which return instance of the Component, ideally new with setted \texttt{props} and \texttt{children}.
  The easiest and most common way to create ComponentFacotry is shown in next example:
  % flatex input: [content/examples/component_factory.tex]
\begin{minted}{dart}
class MyComponent extends Component {
  MyComponent(props, [children]): super(props, children) {}
}

ComponentFactory factory = 
  ([dynamic props, dynamic children]) => new MyComponent(props, children);
\end{minted}

% flatex input end: [content/examples/component_factory.tex]

% }

  \textbf{\texttt{ComponentDescription}} is something, what describes component. 
  It is used as argument to mounting functions and as result of \texttt{render} method.
  It is mostly not used directly, but by \texttt{ComponentDescriptionFactory}, 
  which is method with the same arguments as \texttt{ComponentFacotry}, and returns instance of \texttt{ComponentDescription}.

  It can be created by programmer himself, but mainly, it is created by \texttt{registerComponent} function, which accept one argument of \texttt{ComponentFacotry} type.
  This method created \texttt{ComponentDescriptionFactory}, which returns description with passed \texttt{ComponentFacotry}.
  Usage is shown on following example:
  % flatex input: [content/examples/register_component.tex]
\begin{minted}{dart}
ComponentDescriptionFactory myComponent = registerComponent(factory);
\end{minted}

% flatex input end: [content/examples/register_component.tex]

% }

  This \texttt{ComponentDescriptionFactory} is then used to create description or directly in mounting into HTML element:
  % flatex input: [content/examples/mount_component_description_factory.tex]
\begin{minted}{dart}
Element mountRoot = querySelector("#container");

var props = {};
var children = [];

ComponentFacotry myComponentDescription = myComponent(props, childre);

// Or directly in mountComponent

mountComponent(myComponent(props, children), mountRoot);
\end{minted}

% flatex input end: [content/examples/mount_component_description_factory.tex]

% }

  \subsection{Component}\label{subsec:our-api-component}

    \texttt{Component} class is the main class of the API.
    Every custom component should extend or implement it. 

    It contains constructor, life-cycle methods, \texttt{render} and \texttt{redraw} method, props, children and offer \texttt{needUpdate} stream.
    The whole default \texttt{Component} is this: 
    % flatex input: [content/examples/component.tex]
\begin{minted}{dart}
class Component {
  dynamic props;
  List<ComponentDescription> children;
  final StreamController _needUpdateController;
  Stream<bool> get needUpdate => _needUpdateController.stream; 

  /**
   * Life cycle
   */
  Component(this.props, [this.children]): 
    this._needUpdateController = new StreamController<bool>() {}
  didMount() {}
  willReceiveProps(dynamic newProps) {}
  shouldUpdate(dynamic newProps, dynamic oldProps) => true;
  List<ComponentDescription> render() {}
  didUpdate() {}
  willUnmount() {}
  
  redraw([bool now = false]) {
    _needUpdateController.add(now);
  }
}
\end{minted}
\todo{Sem takúto skrátenú verziu, alebo môžem celý komponent aj s komentami?}

\iffalse
\begin{minted}{dart}
class Component {
  
  /**
   * props of component
   */
  dynamic props;
  
  List<ComponentDescription> children;

  /**
   * stream controller used to signalize to node, 
   * when component need to be udpated
   */
  final StreamController _needUpdateController;

  /**
   * Offer stream which will create event everytime, when it need to be updated (rendered).
   * 
   * Stream use boolean data, which tells, if update should be done immediately
   */
  Stream<bool> get needUpdate => _needUpdateController.stream; 

  /**
   * constructor, it create component with setted stream controller. 
   * 
   * If stream was not passed, it will create own stream controller
   */
  Component(this.props, [this.children]): 
    this._needUpdateController = new StreamController<bool>() {}
  
  didMount() {}

  willReceiveProps(dynamic newProps) {}
  
  shouldUpdate(dynamic newProps, dynamic oldProps) => true;
  
  List<ComponentDescription> render() {}
  
  didUpdate() {}
  
  willUnmount() {}
  
  /**
   * redraw will add event to stream
   */
  redraw([bool now = false]) {
    _needUpdateController.add(now);
  }
}
\end{minted}
\fi

% flatex input end: [content/examples/component.tex]

% }

    The easier way to create own component is by extending, not by implementing it, because extending add default functionality. 
    Simple component should look like this:
    % flatex input: [content/examples/my_component.tex]
\begin{minted}{dart}
class MyComponent extends Component {
  MyComponent(props, [children]): super(props, children) {}

  render() {
    return div(null, [
             span(null, "This is simple component")
           ]);
  }
}
\end{minted}

% flatex input end: [content/examples/my_component.tex]

% }

    We can see, that this \texttt{MyComponent} only renders \texttt{ComponentDescription} of div DOM component which contain children with span description.
    \footnote{DOM component API will be discussed later.}

  \subsection{DOM component API}\label{subsec:our-api-dom}

    There are prepared \texttt{ComponentDescriptionFactory} functions for each of standard HTML elements, which gets standard arguments. 
    They will create new \texttt{ComponentDescription}, with correct factory, which created \texttt{DomComponent} with appropriate tag name.

    These factories can be used like on example of \texttt{MyComponent} in \texttt{render} function.

  \subsection{Browser specific API}\label{subsec:our-api-browser}
    
    There are 3 main addition when components are rendered in browser.
    \begin{itemize}
      \item Mounting
      \item References
      \item Event listeners
    \end{itemize}

    \textbf{Mounting} is implemented by \texttt{mountComponent} function, which have 2 arguments, 
    \texttt{ComponentDescription description} and \texttt{Element mountRoot}.
    It will mount described component into \texttt{mountRoot} element.
    % flatex input: [content/examples/mount_component_description_factory_only.tex]
\begin{minted}{dart}
mountComponent(myComponent(props, children), mountRoot);
\end{minted}

% flatex input end: [content/examples/mount_component_description_factory_only.tex]

% }

    \textbf{References} are part of props. If component have in \texttt{props["ref"]} instance of internal class \texttt{{\textunderscore}Ref}, 
    which is only function returning void with one \texttt{Component} argument, then when this component is created and mounted, 
    this \texttt{{\textunderscore}Ref} is called with it. 

    It is useful, when some custom component want to have reference to element associated to some of it's descendant. 
    Example of usage is something like this:
    % flatex input: [content/examples/ref.tex]
\begin{minted}{dart}
class MyComponent extends Component {
  /* ... */
  Element input;

  render() {
    return input({"ref": (component){
      this.input = getElementForComponent(component);
    }});
  }
}
\end{minted}

% flatex input end: [content/examples/ref.tex]

% }

    \textbf{Event listeners} are also represented as part of props. 
    They should be instance of \texttt{EventListener} class, which is function with 2 arguments, event and component and returns boolean.
    They are used in the same way as references, by adding to props with key in format \texttt{onEventType}:
    % flatex input: [content/examples/event_listener.tex]

\begin{minted}{dart}
input({"onClick": (event, component){
  print("Input clicked.");
}});
\end{minted}

% flatex input end: [content/examples/event_listener.tex]

% }

  \subsection{Server specific API}\label{subsec:our-api-server}

    There is only one thing we want to do on the server, and that is to create markup for some \texttt{ComponentDescription}.
    For this purpose we created method \texttt{mountComponentToString}, which accepts 1 \texttt{ComponentDescription} argument and returns markup, 
    which is identical to what browser part of library should create in DOM.
    % flatex input: [content/examples/mount_component_to_string.tex]
\begin{minted}{dart}
String markup = mountComponentToString(
  span({"class": "my-span"}, "Text it the span")
);
markup == '<span class="my-span">Text in the span</span>' // is true
\end{minted}

% flatex input end: [content/examples/mount_component_to_string.tex]

% }

% flatex input end: [content/chapters/our.tex]

% flatex input: [content/chapters/performance.tex]
\chapter{Performance}\label{chap:performance}

% flatex input end: [content/chapters/performance.tex]

% flatex input: [content/chapters/benchmarks.tex]
\chapter{Benchmarks}\label{chap:benchmarks}


% flatex input end: [content/chapters/benchmarks.tex]

\pagestyle{plain}
% flatex input: [content/chapters/conclusion.tex]
%------------------------------------------------------------------------------------------------------
%  tak isto ako ufod, toto je zaver. V pripade anglictiny premenujte kapitolu...
%------------------------------------------------------------------------------------------------------
\chapter*{Conclusion}\label{chap:conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

Here will be conclusion of wholw thesis


% flatex input end: [content/chapters/conclusion.tex]


% flatex input end: [./content/chapters/chapters.tex]

%------------------------------------------------------------------------------------------------------

\backmatter

%------------------------------------------------------------------------------------
% vyprodukujeme bibliografiu zo suboru literatura.bib
%------------------------------------------------------------------------------------
\nocite{*}
%*flatex input: [main.bbl]
\begin{thebibliography}{INC}

\bibitem[col]{react}
A~Facebook \&~Instagram collaboration.
\newblock {\em {\sl React - A JAVASCRIPT LIBRARY FOR BUILDING USER
  INTERFACES}}.
\newblock \hfill\break{\tt \url{http://facebook.github.io/react/}}.

\bibitem[Goo]{angular}
Google.
\newblock {\em {\sl AngularJS - HTML enhanced for web apps!}}
\newblock \hfill\break{\tt \url{http://angularjs.org/}}.

\bibitem[INC]{ember}
TILDE INC.
\newblock {\em {\sl ember - A framework for creating ambitious web
  applications}}.
\newblock \hfill\break{\tt \url{http://emberjs.com/}}.

\bibitem[Kea]{runloop}
Tyler Keating.
\newblock {\em {\sl The Run Loop}}.
\newblock \hfill\break{\tt
  \url{http://blog.sproutcore.com/the-run-loop-part-1/} and
  \url{http://blog.sproutcore.com/the-run-loop-part-2/}}.

\end{thebibliography}

% flatex input end: [main.bbl]
%FLATEX-REM:\bibliographystyle{alpha}
%FLATEX-REM:\bibliography{literatura.bib}

\addcontentsline{toc}{chapter}{Bibliography}


\end{document}
 

% flatex input end: [main.tex]
