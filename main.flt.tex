% flatex input: [main.tex]
\documentclass[oneside, 12pt]{book}
% \usepackage[slovak]{babel}
\usepackage{epsfig}
\usepackage{color}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{todonotes}
\reversemarginpar
\usepackage[]{algorithm2e}

% flatex input: [./config.tex]

%------------------------------------------------------------------------------------------------------
% pekne pokope definujeme potrebne udaje
%------------------------------------------------------------------------------------------------------
\def\mftitle{Two-way databinding of models and views in Dart}          % nazov diplomovky/bakalarky
\def\mfthesistype{Diploma thesis}             % typ prace
\def\mfkeywords{Databinding, Dart, Facebook React, AngularJS, ... }        % proste klucove slova idealne oddelene ciarkou
\def\mfkeywordsen{Databinding, Dart, Facebook React, AngularJS, ... }      % klucove slova v anglictine EN
\def\mfkeywordssk{Databinding, Dart, Facebook React, AngularJS, ... }      % klucove slova v slovencine SK
\def\mfauthor{Bc. Jakub Uhrík}                            % vase meno a priezvysko
\def\mfadvisor{RNDr. Tomáš Kulich, PhD.}                                  % cele meno skolitela
\def\mfplacedate{Bratislava, 2014}                        % mesto a rok
\def\mfdate{2014}                                         % Rok
\def\mfuniversity{Comenius University in Bratislava}      % Univerzita
\def\mffakulta{Faculty of Mathematics, Physics and Informatics}  % Katedra
\def\mffakultafull{Faculty of Mathematics, Physics and Informatics, Comenius University in Bratislava}  
                                                          % Katedra v plnom zneni aj s univerzitou
\def\mfprogram{Computer Science}                               % studijny program
\def\mfodbor{9.2.1. Computer Science, Informatics}                            % studijny odbor
\def\mfpracovisko{FMFI.KI - Department of Computer Science}                    % skoliace pracovisko


% flatex input end: [./config.tex]

% \usepackage[slovak]{babel}

\usepackage[a4paper,vmargin={25mm,25mm},hmargin={35mm,20mm}]{geometry} 
\usepackage{minted}
\usepackage{caption}
\hyphenpenalty=10000
\tolerance=10000

\usepackage[
	bookmarks=true,
	bookmarksnumbered=false, 	% true means bookmarks in
								% left window are numbered
	bookmarksopen=false,
								% true means only level 1
								% are displayed.
	colorlinks=true,
	pdftitle={\mftitle},
	pdfauthor={\mfauthor},
	pdfsubject={\mfthesistype},
	pdfkeywords={\mfkeywords},
	pdfproducer={\mffakultafull},
	linkcolor=webblue]{hyperref}
\definecolor{webgreen}{rgb}{0, 0.5, 0} % less intense green
\definecolor{webblue}{rgb}{0, 0, 0.5} % less intense blue
\definecolor{webred}{rgb}{0.5, 0, 0}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\definecolor{white}{rgb}{0.95, 0.95, 0.95}
\definecolor{black}{rgb}{0, 0, 0}
%------------------------------------------------------------------------------------------------------
% less intense red
%------------------------------------------------------------------------------------------------------

\usepackage[final]{pdfpages}

 
%------------------------------------------------------------------------------------------------------
% riadkovanie jeden a pol
%------------------------------------------------------------------------------------------------------
\renewcommand\baselinestretch{1.3} 

\def\phrase{\begingroup\phrasenohyphen
	\dononbreakablespace
	\dononbreakablehyphen
	\dophrase}
\makeatletter
\def\phrasenohyphen{%
	\language\@ifundefined{l@nohyphenation}{\@cclv}{\l@nohyphenation}}
\makeatother
\def\dophrase#1{#1\endgroup}

\author{\mfauthor}
\title{\mftitle}

\begin{document}

%------------------------------------------------------------------------------------------------------
% vlozime strukturu, vyplnte ju priamov suboroch, treba len pomenit texty
%------------------------------------------------------------------------------------------------------
% flatex input: [./content/structure/obalka.tex]
%------------------------------------------------------------------------------------------------------
%  toto je subor obalky vasej prace. 
%  s tymto by ste asi ani nemali nic robit pouziju sa prednastavene veci z hlavneho suboru
%------------------------------------------------------------------------------------------------------
\frontmatter

\thispagestyle{empty}

\noindent
\begin{center}
\begin{minipage}{0.8\textwidth}
\centerline{\renewcommand\baselinestretch{1.3} \LARGE\sc\mfuniversity}
\centerline{\sc\mffakulta}
\end{minipage}
\end{center}

\vfill
\begin{center}
\begin{minipage}{1\textwidth}
\bigskip\bigskip
\begin{center}
\linespread{1}\LARGE\sc\mftitle
\end{center}
\smallskip
\centerline{\mfthesistype}
\bigskip
\bigskip
\bigskip\bigskip
\end{minipage}
\end{center}
\vfill
{\bf\mfdate\\
\indent\mfauthor}
\eject 


% flatex input end: [./content/structure/obalka.tex]

%------------------------------------------------------------------------------------------------------

% flatex input: [./content/structure/titulka.tex]
%------------------------------------------------------------------------------------------------------
%  toto je titulna stranka, vsetky veci ste nastavili v config.tex
%------------------------------------------------------------------------------------------------------
\thispagestyle{empty}

\noindent
\begin{center}
\begin{minipage}{0.8\textwidth}
\centerline{\LARGE\sc\mfuniversity}
\centerline{\sc\mffakulta}
\end{minipage}
\end{center}

\vfill
\begin{center}
\begin{minipage}{1\textwidth}
\bigskip\bigskip
\begin{center}
\linespread{1}\LARGE\sc\mftitle
\end{center}
\smallskip
\centerline{\mfthesistype}
\bigskip
\bigskip
\bigskip\bigskip
\end{minipage}
\end{center}
\vfill
\begin{minipage}{0.8\textwidth}
\begin{tabular}{l l}
Study programme:& \mfprogram \\
Field of Study:& \mfodbor \\
Department:& \mfpracovisko\\
Thesis supervisor:&   \mfadvisor \\
\end{tabular}
\end{minipage}
\begin{center}
\end{center}
\vfill
{\bf\mfplacedate\\
\indent\mfauthor}
\eject 


% flatex input end: [./content/structure/titulka.tex]

%------------------------------------------------------------------------------------------------------

% flatex input: [./content/structure/zadanie.tex]
%------------------------------------------------------------------------------------------------------
%  pdf zadania dajte do zlozky images v subore zadanie.pdf tak ako vidite v prikaze. 
%  ak zadavate aj anglicke zadanie, odkomentujte(odstrante percento zo zaciatku) 
%  druhy riadok a podla neho pridajte adekvatne pdf
%------------------------------------------------------------------------------------------------------

\includepdf{images/zadanie-en.pdf}
\includepdf{images/zadanie.pdf}
% \includepdf{images/zadanie-en.pdf}


% flatex input end: [./content/structure/zadanie.tex]

%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% ked treba, da sa vlozit cestne prehlasenie...
%------------------------------------------------------------------------------------------------------
%\input{./content/structure/prehlasenie.tex}

% flatex input: [./content/structure/thanks.tex]
%------------------------------------------------------------------------------------------------------
% Podakovanie. Proste subor s podakovanim. Napiste sem komu dakujete, mozete sa inspirovat mojim
%------------------------------------------------------------------------------------------------------
{~}\vspace{12cm}

\noindent
\begin{minipage}{0.25\textwidth}~\end{minipage}
\begin{center}
\begin{minipage}{1\textwidth}
%------------------------------------------------------------------------------------------------------
%  sem pridajte svoj originalny text, alebo len prepiste \mfadvisor za vysklonovane meno vaseho veduceho
%------------------------------------------------------------------------------------------------------

I would like to thank my supervisor \mfadvisor for his guidance,support, and encouragement throughout writing this thesis. 

Special thanks belong to my family for all their support.

\end{minipage}
\end{center}
\hfill\mfauthor
\vfill\eject 


% flatex input end: [./content/structure/thanks.tex]

%\input{./content/structure/prehlasenie.tex}

% flatex input: [./content/structure/abstract.tex]
%------------------------------------------------------------------------------------------------------
% Toto je subor s abstraktom. Pridajte sem vas/tvoj abstrakt v slovencine a/alebo anglictine
% Ak chcete len jeden abstrakt, vymazte vsetko medzi komentarmi "jazyk zaciatok" a "jazy koniec"
%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% EN zaciatok
%------------------------------------------------------------------------------------------------------
\noindent
\begin{center}
\begin{minipage}{1\textwidth}
\centerline{\large Abstract}
Abstract in english.
%------------------------------------------------------------------------------------------------------
% sem pridajte abstrakt v anglictine
%------------------------------------------------------------------------------------------------------
\\ \\ 
{\bf Key words:} \mfkeywordsen
\end{minipage}
\end{center}
\eject % EOP v
%------------------------------------------------------------------------------------------------------
% EN konie
%------------------------------------------------------------------------------------------------------

%------------------------------------------------------------------------------------------------------
% SK zaciatok
%------------------------------------------------------------------------------------------------------
\noindent
\begin{center}
\begin{minipage}{1\textwidth}
\centerline{\large Abstrakt}
%------------------------------------------------------------------------------------------------------
% sem pridajte abstrakt v slovencine
%------------------------------------------------------------------------------------------------------
Abstrakt v slovencine.
\\ \\ 
{\bf Kľúčové slová:} \mfkeywordssk
\end{minipage}
\end{center}
\eject % EOP v
%------------------------------------------------------------------------------------------------------
% SK konie
%------------------------------------------------------------------------------------------------------


% flatex input end: [./content/structure/abstract.tex]

%\input{./content/structure/prehlasenie.tex}

%------------------------------------------------------------------------------------------------------
% obsah
%------------------------------------------------------------------------------------------------------
\tableofcontents

%------------------------------------------------------------------------------------------------------
% zoznam obrazkov
%------------------------------------------------------------------------------------------------------
\listoffigures

\mainmatter

%------------------------------------------------------------------------------------------------------
% page stype plain pre ciste strany bez cisiel stran pre uvod
%------------------------------------------------------------------------------------------------------
\pagestyle{plain}

%------------------------------------------------------------------------------------------------------
% a teraz includneme vsetky kapitoly, realne je to len subor, v ktorom sa incuduju kapitoly postupne
%------------------------------------------------------------------------------------------------------
% flatex input: [./content/chapters/chapters.tex]
\pagestyle{plain}
% flatex input: [content/chapters/intro.tex]
\chapter*{Introduction}\label{chap:intro}
\addcontentsline{toc}{chapter}{Introduction}

As one of the results of this magister thesis is our new databinding library in dart, 
which is called \textbf{tiles}. 
In next  text, we will use only \textbf{tiles} to mention \textit{our new databinding library in dart}.

% flatex input end: [content/chapters/intro.tex]

\pagestyle{headings}
% flatex input: [content/chapters/motivation.tex]
\chapter{Motivation - why databinding}\label{chap:motivatio}

The first question, as always should be, is the motivation of this work. 
What is the motivation to create another library, that will handle databinding in dart?

We will start with small introduction to history of how websites and later web-applications was created. 
Then we define a set of features required for \textbf{tiles}.

\section{History}\label{sec:history}
\subsection{Plain documents}\label{subsec:history-plain-doc}
\subsection{Simple PHP}\label{subsec:history-server-side-scripts}
\subsection{Server side frameworks}\label{subsec:history-server-side-frameworks}
\subsection{Simple JavaScript/jQuery}\label{subsec:history-jquery}
\subsection{JavaScript MVC frameworks}\label{subsec:history-js-mvc}


\section{Objectives}\label{sec:objectives}

From previous overview of "history" we can produce set of features, 
which should be contained in \textbf{tiles}.

\subsection{Server-side rendering}\label{subsec:objectives-server-side-rendering}
\subsection{Programmer friendly API}\label{subsec:objectives-friendly-api}
\subsection{Easy concept}\label{subsec:objectives-easy-concept}
\subsection{Two way databinding}\label{subsec:objectives-two-way-databinding}

% flatex input end: [content/chapters/motivation.tex]

% flatex input: [content/chapters/databinding.tex]
\chapter{Databinding}\label{chap:databinding}

In this chapter we will introduce problematics of databinding more deeply then in introduction.

\section{One way databinding}\label{sec:onewaydatabinding}

Discuss one way databinding.

\section{Two way databinding}

Discuss two way databinding.

% flatex input end: [content/chapters/databinding.tex]

% flatex input: [content/chapters/existing.tex]
\chapter{Existing solutions}\label{chap:existingsolutions}

\section{Template driven}\label{sec:template}

Discuss databinding based on filling some type of template with model. 
This approach is used in standard MVC frameworks like AngularJS, Ember or UI libraries like Polymer.dart.

\section{Component driven}\label{sec:component}

Discuss databinding based on component approach used for example in React from facebook or our library.


% flatex input end: [content/chapters/existing.tex]

% flatex input: [content/chapters/our.tex]
\chapter{Our solution}\label{chap:oursolution}

In this chapter we will introduce and deeply describe our Dart library \texttt{Tiles}.


\section{Requirements}\label{subsec:our-architecture-requirements}

  In this section we write down a list of requirements on our library.

\section{Architecture}\label{sec:our-architecture}

  In this section we describe our architecture from couple points of view like \nameref{subsec:our-architecture-idea}, 
  \nameref{subsec:our-architecture-structure}, 
  \nameref{subsec:our-architecture-core}, 
  \nameref{subsec:our-architecture-lifecycle}, 
  \nameref{subsec:our-architecture-events}, 
  \nameref{subsec:our-architecture-rendering} and
  \nameref{subsec:our-architecture-injecting}.

  We will focus on good understanding of how library works. 
  We will not discuss API a lot, this is the focus of next section. 

  But, of cause we add some examples, so wee will show some parts of api in this section too, 
  but they don't will be so much described as in next section.

  \subsection{High level idea}\label{subsec:our-architecture-idea}
    Our high level idea inherit from facebook react library. 
    We created api, whose main class is \texttt{Component}, which represents construct very similar to react's \texttt{Component}.
    This component is mounted to some element, where it renders itself. 
    This relationship is shown on figure~\nameref{img:library-idea}.
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/Idea.png}
      \caption{Idea}
      \label{img:library-idea}
    \end{figure}


    These components are somehow placed into tree structure, which represents \mbox{\textbf{\nameref{img:library-idea-virtual-dom}}}, 
    which is then translated to real DOM of client's browser or to markup rendered by server application.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Idea/IdeaObjects.png}
      \caption{Virtual DOM}
      \label{img:library-idea-virtual-dom}
    \end{figure}
    There can be event listeners attached to these components. 
    \textbf{Events} \footnote{We work at Dart, which create browser compatibility for us, so we don't have to create synthetic events like react.}
    are then bubbled trough virtual DOM, instead real one.
    By this there can be listener attached to custom component, which don't have element representing it in real DOM.

    As we work in Dart language, it is natural to try to reuse most of code on both, client and server.
    So other important part of idea is \textbf{server-side rendering}, 
    which is meant to easy rendering the same content on server as on client's browser.
    It is very important for SEO purposes and smooth user experience. 

  \subsection{Structure}\label{subsec:our-architecture-structure}

    We split our library to 3 partially dependent packages. 
    \begin{description}
      \item[Tiles] \hfill \\
        \textbf{Tiles} creates the core component's of library, focused to create and maintain virtual DOM and offer API for programmer.
        This package should be included by programmer in files, where he define custom components. 
        These components then can be used both, on server and in browser application.
      \item[Tiles Browser] \hfill \\
        These package is used for mounting components to real HTML elements. 
        It maintain relationships between elements and components, 
        simulate events bubbling and keep real DOM in sync with virtual one.
      \item[Tiles Server] \hfill \\
        \textbf{Tiles Server} maintain server-side rendering. It offers api to render component structure to string with markup based on DOM components.
    \end{description}

    From this it is quiet obvious what are dependences between these packages. 
    \texttt{\textbf{Tiles}} is independent, and both of \texttt{\textbf{Tiles Browser}} and \texttt{\textbf{Tiles Server}} are dependent on \texttt{\textbf{Tiles}}.
    These dependences are shown on figure~\nameref{img:library-packages}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/Packages.png}
      \caption{Packages}
      \label{img:library-packages}
    \end{figure}

  \subsection{Core}\label{subsec:our-architecture-core}
    We have 4 main classes in core of the library.
    \begin{description}
      \item[Component] 
        represents closed block of user interface, 
        which should be rendered in application.
      \item[Node]
        is a vertex in tree of virtual DOM. 
        It contains instance of \texttt[Component], which represents type of this \texttt{Node}.
      \item[ComponentDescription]
        is, as it sound like, description of a component. 
        It is returned from component to describe it's children. 
        We discuss this principle later.
      \item[NodeChange]
        represents one change in virtual DOM, which should be applied into real DOM. 
        By this, we achieve changing real DOM by smallest difference in virtual DOM. 
        Types of change are \texttt{CREATED, UPDATED, MOVED, DELETED}
    \end{description}

    In contrast with facebook react \texttt{Component}, our component do nothing else than api offered to programmer.
    This class is the main class for programmer which use our library, he don't need to use any other class created by our library. 
    Just some methods.

    We also got inspiration from react with idea of \textbf{virtual DOM}. 
    This virtual DOM is not represented by tree of components, but to separate functionality, 
    it's vertices are constructed by instances of class \texttt{Node}.

    Every node contain instance of \texttt{Component}. 
    For this \texttt{Component} instance this node is something like \textit{representer of me in virtual DOM}.
    
    The whole image of relationships is shown on figure~\nameref{img:library-core}. Now we will focus on the main classes separately. 
    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.2]{images/uml/tiles/TilesCore/Core.png}
      \caption{Core of the library}
      \label{img:library-core}
    \end{figure}

    \subsubsection{Component}\label{subsubsec:our-architecture-core-component}
      Component, as in react, is the main building brick of application(library). 
      It offers api to the programmer with life-cycles, props and so on. 

      Life-cycle methods will be discuss later, lets focus on the role of component in the whole library.

      Component is a class, which represents functionality of certain part of UI\footnote{UI = User Interface} in an application.
      It is created with some props and children and it is upon it to do what ever it wants with it. 
      But main purpose of it is to create some structure below\footnote{From the virtual DOM tree point of view} it, 
      add some event listeners and update itself sometimes, e.g. on some event occur.

      The main method of the \texttt{Component} is \texttt{List<ComponentDescription> render()}. 
      By this method component creates it's substructure.
      It will return list of children of this component, represented by instance of \texttt{ComponentDescription}. 
      \texttt{Node}, which owns this component (and called it's render method) will take care of the rest.
      Basically, it will return something like \textit{"This is how I should look like"}.

      Second important method is \texttt{void redraw()}, which trigger redraw of the component. 
      This redraw will be executed on the first next animation frame. 

      Redraw is powered by \texttt{needUpdate} stream offered by \texttt{Component}, 
      which is automatically created in default constructor of class \texttt{Component}, 
      so it is very important, to call superclass constructor in each custom component class.

      \texttt{ComponentDescriptionFactory registerComponent(ComponentFactory factory)} is also very helpful method. 
      By passing it it gets \texttt{ComponentFactory} as an argument and from it, create \texttt{ComponentDescriptionFactory}. 
      This is mainly created for easy use of the library, we will show why these factories exists and how are they used in section~\nameref{sec:our-api}
      
    \subsubsection{DomComponent}\label{subsubsec:our-architecture-core-dom-component}
      \texttt{DomComponent} is a subclass of class \texttt{Component}. 
      This is specialized class, which represents HTML elements in the component structure.

      It has \texttt{props} saved as \texttt{Map}, because HTML element have attributes saved in \texttt{Map},
      \texttt{render} method, which return \texttt{children} member variable and \texttt{svg} and \texttt{pair} flags.

      Specific HTML elements are then created as with different \texttt{ComponentFactory} and also different \texttt{ComponentDescriptionFactory}, 
      which is used to easily create \texttt{ComponentDescription}s of \texttt{DomComponent} in custom component render method. 

    \subsubsection{ComponentDescription}\label{subsubsec:our-architecture-core-component-description}
      \texttt{ComponentDescription} is description of a component. 
      It describes what component should be rendered.

      For this purpose, it's need 4 types of information:
      \begin{itemize}
        \item \textbf{Type of the component} \hfill \\
          To create instance of some component, we need to know, what type (class) of the component it should be. 
          This information is represented by \texttt{ComponentFactory}, 
          which is function with 2 parameters, \texttt{props} and \texttt{children}, 
          which returns instance of a subclass of a \texttt{Component}.
        \item \textbf{Properties} \hfill \\
          Data which should be passed to the factory, to be new component created with them.
        \item \textbf{Children} \hfill \\
          Children of described component.  
          This is useful mainly when programmer want to render more complex structure of \texttt{DOMComponent}s.
        \item \textbf{Key} \hfill \\
          Key is an identifier of a child. If component's function render returns list of children with keys, 
          and after update it returns the same children but in different positions, 
          tiles only reorder this children and not remove, add them or change their properties. 
      \end{itemize}

      It has all these information as final. Description is once created, 
      with all informations and then these information can't be changed. 
      All these information is setted up bu constructor. 

      \texttt{ComponentDescription} have one important method, which is\texttt{Component createComponent()}, 
      which creates \texttt{Component} instance with props and children from the description.

    \subsubsection{Node}\label{subsubsec:our-architecture-core-node}
      \texttt{Node} is the most important and complex class in the library.
      It creates virtual DOM tree, maintain creating and updating of it based on results of component's \texttt{render} method, 
      listen to component's \texttt{needUpdate} stream and mark self as \textit{"dirty"} when it's component need update 
      and handle process of updating which rearrange children of the \texttt{Node}.

      Children are stored trough class \texttt{NodeChild}, which represents all information about child (node, component's factory and key). 
      By this encapsulation, when update is triggered, we can compare factory of a component description and factory of a child 
      and decide, if we need to replace this child or it is enough to update it. 

      As the key is also stored in \texttt{NodeChild}, we also compare old children with next one when doing update, 
      and if there exists child in old children with the same key as in the next one, this child "step out of the line" 
      and only move around without replacing.
      
      Node have two important flags: \texttt{isDirty} and \texttt{hasDirtyDescendant}. 
      These flags represents information, if some node need to be redrawn.
      If \texttt{isDirty} is true, this node need to be updated, 
      because component of this node called \texttt{redraw}.
      If \texttt{hasDirtyDescendant} is true, that means, 
      that there exist a descendant of this node, which want to be updated.
      When \texttt{hasDirtyDescendant} is true and \texttt{isDirty} is false, 
      component don't have to update itself, it is enough to call update on child nodes.

      Method \texttt{List<NodeChange> update()} is doing this update process. 
      It returns list of changes, which was needed to put node in new state.
      This update is mainly called by browser part of a library and this list is used to translate changes in virtual DOM to real one. 
      Method consists of several main steps.
      \begin{enumerate}
        \item check, if update is needed by flags \texttt{isDirty} and \texttt{hasDirtyDescendant}, if no, return,
        \item if component of this node need update (\texttt{isDirty == true}), update this node with rearrangement of children,
        \item add results of update calls on children to result,
        \item set this node as not dirty and not have dirty descendant and return.
      \end{enumerate}

      Rearrangement of children by calling \texttt{render} method of this component 
      and adapting node's children to returned descriptions 
      has not so difficult as complex algorithm, which we will not describe here. 
      It is fully documented in the source code related to this work, 
      extracted to specific method private to the library which is in own file:
      \url{https://github.com/cleandart/tiles/blob/master/lib/src/core/node_update_children.dart}

    \subsubsection{NodeChange}\label{subsubsec:our-architecture-core-node-change}
      \texttt{NodeChange} take place as a record of a change in the virtual DOM. 
      It is used to mirror changes in the virtual DOM with real DOM. 

      When some node in the virtual DOM is updated by method \texttt{update}, list of changes is returned. 
      This list is then processed by browser part of a library, which mirror these changes to real DOM.

      \texttt{NodeChange} class has no methods (except constructor) and act just as a data chunk specialized for it's purpose. 
      It contains node, type of change, old and next properties. 

      Type is stored as instance of \texttt{NodeChangeType} enum and can be one of \texttt{CREATED}, \texttt{UPDATED}, 
      \texttt{MOVED} and \texttt{DELETED}, whom meaning is obvious. 
      When type is \texttt{UPDATED}, old props and new pros take effect. 

  \subsection{Life-cycle}\label{subsec:our-architecture-lifecycle}

    Every instance of \texttt{Component} have own life-cycle. 
    As every object, first it is created. 
    Then, when component is mounting or rendering into text, it is rendered, and then it is mounted.
    Then it lives it's own life. 

    When something "higher" want to update it, it will first receive props, 
    then it is asked, if it should be updated, and if yes, then it is rendered.
    After that, it was updated, of course.

    Sometimes component want to update itself (e.g. because some event occurs).
    It calls redraw, then, it will be asked if really should update, and if yes, it is rendered and update.

    At the end of component's life, 
    component should be notified about that it will be unmounted(e.g. from DOM), 
    to be able, to do some modifications to it's refs, destroy timers and so on. 

    This whole life-cycle is shown on the figure~\nameref{img:our-life-cycle}.

    \begin{figure}[h]
    \centering  
      \includegraphics[scale=0.6]{images/uml/tiles/TilesCore/LifeCycle.png}
      \caption{Life cycle of a \texttt{Component}}
      \label{img:our-life-cycle}
    \end{figure}

    \subsubsection{Create}\label{subsec:our-architecture-lifecycle-create}

      Create part of life-cycle is implemented by constructor of \texttt{Component}. 
      It will receive props and optionally children as arguments and 
      it should do whatever it needs to prepare whole state of object to live.

      An trivial example of constructor of \texttt{Component} is 
      % flatex input: [content/examples/my_component_constructor.tex]
      \begin{minted}{dart}
class MyComponent extends Component {
  MyComponent(props, [children]): super(props, children) {}
}
      \end{minted}

% flatex input end: [content/examples/my_component_constructor.tex]

      which only call's constructor of super class \texttt{Component}

      Example of more complex constructor should be e.g. component 
      which maintain example \texttt{Todo} instance.
      % flatex input: [content/examples/my_todo_component_constructor.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  MySearchComponent(props, [children]): super(props, children) {
    if (props != null && props.todo is Todo) {
      this.todo = props.todo
    } else {
      this.todo = new Todo();
    }
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_constructor.tex]


    \subsubsection{Did mount}\label{subsec:our-architecture-lifecycle-didmount}

      \texttt{Component} life-cycle \textbf{Did mount} is implemented by method \texttt{didMount}. 
      It is called after component is mounted to DOM. 

      This is the correct place to initialize for example timers, stream listeners and so on. 

      For example, in our \texttt{MyTodoComponent} we should listen for change of todo on server, 
      and if it was changed, we can redraw component.
      % flatex input: [content/examples/my_todo_component_didmount.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  didMount() {
    this.subscription = this.todo.changedOnServer.listen((change) {
      this.redraw();
    });
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_didmount.tex]


    \subsubsection{Will receive props}\label{subsec:our-architecture-lifecycle-willreceiveprops}

      Will receive props life-cycle method is \texttt{willReceiveProps}. 
      It is called every time, when component will recevie new \texttt{props}, 
      except first time, when these \texttt{props} are passed to constructor.

      This is place, where old props and new props can be compared, 
      so this is right place to make changes based on difference in old and new props.

      Example of \texttt{willReceiveProps} in our \texttt{MyTodoComponent} 
      should compare \texttt{todo} of old and new props and there are not equal, 
      it can update change listener.
      % flatex input: [content/examples/my_todo_component_willreceiveprops.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  willReceiveProps(dynamic newProps) {
    if (this.todo != newProps.todo) {
      this.subscription.cancel();
      this.subscription = newProps.todo.changedOnServer.listen((change) {
        this.redraw();
      });
    }
  }

  // ...
}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_willreceiveprops.tex]

      
      
    \subsubsection{Should update}\label{subsec:our-architecture-lifecycle-shouldupdate}
      Should update is partly lifecycle, partly not. 
      It is a question, if component should update on  this props-change. 

      This "life-cycle" is implemented by method \texttt{shouldUpdate}. 
      This method is used mainly for speed up performance. 
      By default it returns true, 
      so if it is not implemented in custom component, 
      it will update always.

      In basic scenario this method recognize, 
      if it will be rendered differently with new props.  
      If not, it return false, else it return true.

      Example in \texttt{MyTodoComponent} should look like this:
      % flatex input: [content/examples/my_todo_component_shouldupdate.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  shouldUpdate (newProps, oldProps) {
    if (newProps.todo == oldProps.todo) {
      return false;
    }
    return true;
  }

  // ...

}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_shouldupdate.tex]


    \subsubsection{Render}\label{subsec:our-architecture-lifecycle-render}

      Render is the main part of the \texttt{Component}. 

      It is implemented by method \texttt{render}, which have no attributes.
      It should return array of component descriptions which should be considered as 
      \textit{"this is how this component should look like"}.

      For example, in our \texttt{MyTodoComponent} render will return \texttt{<div>} which contains title and description of \texttt{todo}.
      % flatex input: [content/examples/my_todo_component_render.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  render () {
    return div ({"class": "todo"}, [
      h2 ({}, todo.title),
      p ({}, todo.description)
    ]);
  }

  // ...

}
      \end{minted}


% flatex input end: [content/examples/my_todo_component_render.tex]


    \subsubsection{Did update}\label{subsec:our-architecture-lifecycle-didupdate}

      When life-cycle method \texttt{didUpdate}, 
      by which is implemented this life-cycle event, 
      is triggered, component, and programmer, can be sure, 
      that component is mounted and there exist elements in DOM for each DomComponent descendant.

    \subsubsection{Will unmount}\label{subsec:our-architecture-lifecycle-willunmount}

      This event is implemented by method \texttt{willUnmount}, which contain no arguments.
      
      It is called right before it is unmounted from dom. 

      This is the correct place to stop all timers and listeners.
      % flatex input: [content/examples/my_todo_component_willunmount.tex]
      \begin{minted}{dart}
class MyTodoComponent extends Component {
  Todo todo;
  StreamSubscription subscription;

  // ...

  willUnmount () {
    subscription.cancel();
  }

  // ...

}
      \end{minted}

% flatex input end: [content/examples/my_todo_component_willunmount.tex]


  \subsection{Rendering}\label{subsec:our-architecture-rendering}
    The main target of our library is rendering of a content. 
    By \texttt{Component} and \texttt{Node} we can create virtual DOM tree, 
    but now we want to render this structure into something independent from our library. 

    As our work is in the scope of web applications, we want to render it into DOM (browser rendering), 
    and also into textual representation of a DOM(server rendering).

    As we described earlier in subsection~\nameref{subsec:our-architecture-structure}, 
    these rendering types are separated to separate packages from the core package and are independent from each other. 

    \subsubsection{Server side}\label{subsec:our-architecture-rendering-server}
      On the server, we don't have DOM elements available, 
      because of that we want to render our virtual DOM structure into a string,
      which user of this library can return as a response to browser request.

      When we have string, which represents markup of DOM created from virtual DOM, 
      created by our library, we can do server-side databinding, 
      which can be reuse in the browser to smooth user experience. 

      Our target, render virtual DOM into markup string is quiet easy.
      From the programmers point of view, he will use \texttt{ComponentDescription} to describe, 
      what component he want to render. 
      Our server-side package of library will get this description, creates component from it, 
      puts it into node and perform update of node. 
      By this, virtual DOM is created. 

      Now, as we have virtual DOM, we can render it's markup by depth-first search of it's tree. 
      In the search, when we came into node, we will do something like this algorithm (pseudo-code):
      \begin{algorithm}[H]
        \KwData{node in virtual DOM}
        \KwResult{String with markup of subtree of virtual DOM with root in setted node}
        % initialization\;
        % \While{not at end of this document}{
        % read current\;
        \eIf{component is DomComponent}{
          \eIf{component is not pair}{
            write markup with attributes from props\;
          }{
            write open markup\;
            write markup for all children recursively\;
            write close markup\;
          }
        }{
          write markup for all children recursively\;
        }
        % }
        \caption{Write node into string.}
      \end{algorithm}

    \subsubsection{In browser}\label{subsec:our-architecture-rendering-browser}
      Rendering in browser is quiet more difficult than rendering to string. 
      We can use same render to string method, but we will need some connections between nodes and elements, 
      so we can't do it this simply.

      \paragraph{Initial mount}\label{par:our-architecture-rendering-browser-init} 
        First the user of the library need to do is to mount component to the HTML element. 
        Of cause, he will mount component description, not component directly.
        When component is mounting, it is created, placed into the node and after this, node is "updated". 
        It is initial update which creates virtual DOM. 

        When virtual DOM is created, we need to construct real DOM under the root element 
        (element, which was component mounted to) from "virtual image".

        For now, we describe case, that root element is empty (has no child element or node).
        Case, when it is not empty we discussed in the subsection~\nameref{subsec:our-architecture-injecting}.
        The mount is easily described by next algorithm:
        \begin{algorithm}[H]
          \KwData{node in virtual DOM and HTML element, to mount node to (mountRoot)}
          \KwResult{Mounted node into element}
          % initialization\;
          % \While{not at end of this document}{
          % read current\;
          \eIf{node.component is DomComponent}{
            \eIf{node.component is not pair}{
              create element representing component\;
              add created element to mountRoot\;
            }{
              create element representing component\;
              add created element to mountRoot\;
              \For{child in node.children} {
                run recursively with created element as mountRoot and child as node\;
              }
            }
            save relations between created element and node;
          }{
            \eIf{node.component is tex component}{
              create HTML text node with text from component\;
              add text node to mountRoot\;
              save relations between created text node and node;
            }{
              \For{child in node.children} {
                run recursively with mountRoot and child as node\;
              }
            }
          }
          % }
          \caption{Write node into string.}
        \end{algorithm}

        As we can see, algorithm is recursive and skips custom components. 
        Also it creates relations between created elements and nodes. 
        Which are these relations we discuss later, when we need them.

        By this algorithm, it is obvious, that we have real DOM with the same structure, 
        if we can obtain from virtual DOM by removing nodes with custom components 
        and connect their children with their parent.

      \paragraph{Update}\label{par:our-architecture-rendering-browser-update} 
        Later, there can be situation, that virtual DOM want to be updated. 
        This is when some node was marked as \textit{dirty}.
        Then framework perform update of this node, 
        which triggers update of the subtrees with roots in dirty nodes.
        This updates return lists of changes in virtual DOM, 
        which should be applied to browser element structure.

        These updates should be processed by it's type. 
        But for every type we need the information about which HTML element represents some node. 
        This is first relation, which we need to remember, when we initialize mounted relation, 
        relation \mbox{\texttt{Node $\rightarrow$ Element}}. 
        This relation is stored by map \texttt{Map<Node, Element>}.

        But what happened when we want to apply node change into real DOM structure?
        For each type of change something different of cause:
        \begin{description}
          \item[CREATED]
            when new node is created, it should be mounted into the DOM. 
            If it has \texttt{DomComponent} inside, HTML element will be created and placed at the correct place. 
            If it has some custom component, this change will be ignored. 
          \item[UPDATED]
            If node was updated, then if it has \texttt{DomComponent}, it's element is updated with setted props.
          \item[MOVED]
            Node or it's children(if it is node with custom component) is moved to new position.
          \item[DELETED]
            Element of node or elements of its descendants(if it is node with custom component) are removed from DOM.
        \end{description}

  \subsection{Events}\label{subsec:our-architecture-events}
    As we were created dart library which creates virtual DOM, composed from nodes, which contains components, 
    it is obvious that we can "simulate" event bubbling trough this virtual DOM. 

    This is fully in domain browser part of a library.
    \todo{Add more content.}

  \subsection{Injecting}\label{subsec:our-architecture-injecting}

\section{API}\label{sec:our-api}

  Documentation of offered API of our library.

  \subsection{Component}\label{subsec:our-api-component}
  \subsection{Browser specific API}\label{subsec:our-api-browser}
  \subsection{Server specific API}\label{subsec:our-api-server}

% flatex input end: [content/chapters/our.tex]

% flatex input: [content/chapters/performance.tex]
\chapter{Performance}\label{chap:performance}

% flatex input end: [content/chapters/performance.tex]

% flatex input: [content/chapters/benchmarks.tex]
\chapter{Benchmarks}\label{chap:benchmarks}


% flatex input end: [content/chapters/benchmarks.tex]

\pagestyle{plain}
% flatex input: [content/chapters/conclusion.tex]
%------------------------------------------------------------------------------------------------------
%  tak isto ako ufod, toto je zaver. V pripade anglictiny premenujte kapitolu...
%------------------------------------------------------------------------------------------------------
\chapter*{Conclusion}\label{chap:conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

Here will be conclusion of wholw thesis


% flatex input end: [content/chapters/conclusion.tex]


% flatex input end: [./content/chapters/chapters.tex]

%------------------------------------------------------------------------------------------------------

\backmatter

%------------------------------------------------------------------------------------
% vyprodukujeme bibliografiu zo suboru literatura.bib
%------------------------------------------------------------------------------------
\nocite{*}
%*flatex input: [main.bbl]
\begin{thebibliography}{{JQU}12}

\bibitem[{Aja}10]{restfullservice}
{AjaxPatterns.org Wiki}.
\newblock {\em {RESTful Service}}, 2010.
\newblock \hfill\break{\tt \url{http://ajaxpatterns.org/RESTful_Service}}.

\bibitem[jav12]{javawebframework}
{\em {Java web frameworks discussed}}, 2012.
\newblock \hfill\break{\tt
  \url{http://entjavastuff.blogspot.com/2012/01/java-web-frameworks-discussed.html}}.

\bibitem[{JQU}12]{jqueryui}
{JQUERY FOUNDATION AND THE JQUERY UI TEAM.}
\newblock {\em {\sl jQueryUI Demos \& Documentation}}, 2012.
\newblock \hfill\break{\tt \url{http://jqueryui.com/demos/}}.

\bibitem[{Mic}]{msdnmvc}
{Microsoft Developer Network}.
\newblock {\em {Model-View-Controller}}.
\newblock \hfill\break{\tt
  \url{http://msdn.microsoft.com/en-us/library/ff649643.aspx}}.

\bibitem[Nie03]{alertbox}
Jakob Nielsen.
\newblock {\em {\sl Usability 101: Introduction to Usability}}, 2003.
\newblock \hfill\break{\tt \url{http://www.useit.com/alertbox/20030825.html}}.

\bibitem[{Ste}07]{restintro}
{Stefan Tilkov}.
\newblock {\em {A Brief Introduction to REST}}, 2007.
\newblock \hfill\break{\tt
  \url{http://www.infoq.com/articles/rest-introduction}}.

\bibitem[{Sun}02]{sunmvc}
{Sun Microsystems, Inc. All Rights Reserved}.
\newblock {\em {Java BluePrints: Model-View-Controller}}, 2002.
\newblock \hfill\break{\tt
  \url{http://java.sun.com/blueprints/patterns/MVC-detailed.html}}.

\bibitem[TS]{javascriptMVCmanual}
Jupiter Consulting~JavaScriptMVC Training and Support.
\newblock {\em {\sl JavaScriptMVC Documentation}}.
\newblock \hfill\break{\tt \url{http://javascriptmvc.com/docs.html}}.

\bibitem[{zen}]{play}
{zenexity \& Typesafe}.
\newblock {\em {\sl Play 2.0 documentation}}.
\newblock \hfill\break{\tt
  \url{http://www.playframework.org/documentation/2.0.1/Home}}.

\end{thebibliography}

% flatex input end: [main.bbl]
%FLATEX-REM:\bibliographystyle{alpha}
%FLATEX-REM:\bibliography{literatura.bib}

\addcontentsline{toc}{chapter}{Bibliography}


\end{document}
 

% flatex input end: [main.tex]
